[{"title":"荼菜的iOS笔记--一些实用功能。","date":"2017-03-02T08:52:56.000Z","path":"2017/03/02/荼菜的iOS笔记-一些实用功能。/","text":"前言：开发过程中遇到许多不太熟练的知识点，这些都是借鉴别人又被我应用的一些东西，之前是遇到一点就记录到笔记里，时间久了知识点就有点散，正好整理到一起，欢迎收藏，以后还会陆续增加知识点。 1.不常用的属性1234567891011121314151617181920//取消自动布局self.automaticallyAdjustsScrollViewInsets = NO;//解决tabbar挡住最后一行问题self.edgesForExtendedLayout = UIRectEdgeNone;//隐藏cell线 self.tableView.separatorStyle = UITableViewCellSeparateStyleNone;//push到下个页面需要隐藏tabBar时svc.hidesBottomBarWhenPushed=YES;//多余cell空白self.tableView.tableFooterView = [[UIView alloc]init];//不超过屏幕也能滑self.ShowCollection.alwaysBounceVertical = YES;//选中cell 无背景色cell.selectionStyle = UITableViewCellSelectionStyleNone;//推时隐藏tabbarself.hidesBottomBarWhenPushed = YES;//button文字靠右[_button setContentHorizontalAlignment:UIControlContentHorizontalAlignmentRight];//button文字靠左[_button setContentHorizontalAlignment:UIControlContentHorizontalAlignmentLeft]; 2.解决时差问题1234567891011121314151617181920212223242526272829303132333435 //解决时差问题 NSDate * date = sender.date; NSTimeZone *zone = [NSTimeZone systemTimeZone]; NSInteger interval = [zone secondsFromGMTForDate: date]; NSDate *localeDate = [date dateByAddingTimeInterval: interval]; //时差转化 NSDate *datenow = [NSDate date];//输出结果:2014-12-12 02:23:25 +0000晚八个小时 NSTimeZone *zone = [NSTimeZone systemTimeZone]; NSInteger interval = [zone secondsFromGMTForDate:datenow]; NSDate *localeDate = [datenow dateByAddingTimeInterval: interval];//2014-12-12 10:23:25 +0000 NSLog(@&quot;%@&quot;, localeDate); //将秒数转化为日期格式 NSDate *confromTimesp = [NSDatedateWithTimeIntervalSince1970:1363948516]; NSLog(@&quot;1363948516 = %@&quot;,confromTimesp);//2013-03-22 10:35:16 +0000//将秒数转化为特定格式的日期格式NSString *str=@&quot;1368082020&quot;;//时间戳 NSTimeInterval time=[str doubleValue]+28800;//因为时差问题要加8小时 == 28800 sec NSDate *detaildate=[NSDate dateWithTimeIntervalSince1970:time]; NSLog(@&quot;date:%@&quot;,[detaildate description]); //实例化一个NSDateFormatter对象 NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; //设定时间格式,这里可以设置成自己需要的格式 [dateFormatter setDateFormat:@&quot;yyyy-MM-dd&quot;]; NSString *currentDateStr = [dateFormatter stringFromDate: detaildate];//最终版本 NSString * startStr = [NSStringstringWithFormat:@&quot;%@&quot;,dic[@&quot;startdate&quot;]]; NSTimeInterval startTime = [startStr doubleValue] / 1000 + 28800; NSDate * startLocalDate = [NSDatedateWithTimeIntervalSince1970:startTime]; NSDateFormatter * startFormatter = [[NSDateFormatter alloc]init]; [startFormatter setDateFormat:@&quot;yyyy.MM.dd&quot;]; NSString * startDate = [startFormatter stringFromDate:startLocalDate]; 3.页面切换水波纹动画12345678DetailViewController * dvc = [[DetailViewControlleralloc]initWithSid:self.dataArray[indexPath.row] [@&quot;secid&quot;]WithCollectorsCount:[self.dataArray[indexPath.row][@&quot;collectcnt&quot;]intValue]]; dvc.hidesBottomBarWhenPushed = YES; CATransition*transition=[CATransition animation]; transition.duration=1.0f; transition.type=@&quot;rippleEffect&quot;; transition.subtype=@&quot;fromTop&quot;; [self.navigationController.view.layer addAnimation:transitionforKey:nil]; [self.navigationController pushViewController:dvc animated:YES]; 4.去掉导航条和tabBar的边框1234567- (void)viewWillAppear:(BOOL)animated &#123; [self.navigationController.navigationBar setBackgroundImage:[TDUtils createImageWithColor:[UIColor clearColor]] forBarMetrics:UIBarMetricsDefault]; [self.navigationController.navigationBar setBackIndicatorTransitionMaskImage:[TDUtils createImageWithColor:[UIColor clearColor]]]; [self.navigationController.navigationBar setShadowImage:[TDUtils createImageWithColor:[UIColor clearColor]]]; [self.tabBarController.tabBar setBackgroundImage:[TDUtils createImageWithColor:[UIColor clearColor]]]; [self.tabBarController.tabBar setShadowImage:[TDUtils createImageWithColor:[UIColor clearColor]]];&#125; 5.导航条多按钮12NSArray *buttonArray = [[NSArray alloc]initWithObjects:cleanButton,saveButton, nil];self.navigationItem.rightBarButtonItems = buttonArray; 6.真机测试时出现的问题1234567No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=armv7, VA运行报错出现的原因：armv7s是应用在iPhone 5 A6 的架构上的解决的方式：1，在Project target里“Architectures”设置为“Standard （armv7,armv7s）”2，修改在Project target里“Build Settings”的“Valid Architectures”添加“i386”和“armv7”(Xcode4.6 以上版本不再支持armv6，请去掉)3,设置”Build Active Architecture Only”为“NO”。这样你build你的项目的时候就能在iphoe5和iphoe4s里执行。 7.datepicker修改为中文12345方法一[datePicker setLocale:[[NSLocale alloc]initWithLocaleIdentifier:@&quot;zh_CN&quot;]];方法二NSLocale *locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;];//设置为中文显示3 _datePicker.locale = locale; 8.设置属性字体12345678910NSMutableParagraphStyle *ps = [[NSMutableParagraphStyle alloc] init];[ps setLineHeightMultiple:lineHeight];//行高 [ps setLineSpacing:lineHeight];//行间距ps.lineBreakMode = NSLineBreakByTruncatingTail;//末尾省略号ps.lineHeightMultiple = TextLineHeight; //行间距NSMutableDictionary *attributesDic= [NSMutableDictionary dictionary];attributesDic[NSForegroundColorAttributeName] = stringColor;attributesDic[NSFontAttributeName] = stringFont;attributesDic[NSKernAttributeName] = @(0.5);//字间距attributesDic[NSParagraphStyleAttributeName] = ps;NSMutableAttributedString *attributedText = [[NSMutableAttributedString alloc] initWithString:string attributes:attributesDic]; 9.屏幕不允许旋转的方法是什么？1234- (NSUInteger)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window&#123; return UIInterfaceOrientationMaskPortrait;&#125; 10.电池状态栏改变颜色1234567891011121314151617181920212223方法一：不用修改plist [self.navigationController.navigationBar setBarStyle:UIBarStyleBlack];默认的黑色（UIStatusBarStyleDefault）白色（UIStatusBarStyleLightContent）- (UIStatusBarStyle)preferredStatusBarStyle&#123; return UIStatusBarStyleLightContent;&#125;方法二：需要修改plist[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleDefault animated:NO];/ 设置状态栏字体颜色中国移动的颜色改为白色（需要设置plist文件里的View controller-based status bar appearance属性为NO；） [UIApplication sharedApplication].statusBarStyle=UIStatusBarStyleLightContent;//隐藏项目中得状态栏 [[UIApplication sharedApplication]setStatusBarHidden:YES withAnimation:UIStatusBarAnimationFade];info.plist文件中Status bar is initially hidden yesView controller-based status bar appearance NO 11.通过抖动的方式提示用户textField文本输入框的text值为空或错误12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//TextField的晃动:Begin @interface UITextField(shake) - (void)shake; @end @implementation UITextField(shake) - (void)shake &#123; CAKeyframeAnimation *animationKey = [CAKeyframeAnimationanimationWithKeyPath:@&quot;position&quot;]; [animationKey setDuration:0.5f]; NSArray *array = [[NSArrayalloc] initWithObjects: [NSValuevalueWithCGPoint:CGPointMake(self.center.x, self.center.y)], [NSValuevalueWithCGPoint:CGPointMake(self.center.x-5, self.center.y)], [NSValuevalueWithCGPoint:CGPointMake(self.center.x+5, self.center.y)], [NSValuevalueWithCGPoint:CGPointMake(self.center.x, self.center.y)], [NSValuevalueWithCGPoint:CGPointMake(self.center.x-5, self.center.y)], [NSValuevalueWithCGPoint:CGPointMake(self.center.x+5, self.center.y)], [NSValuevalueWithCGPoint:CGPointMake(self.center.x, self.center.y)], [NSValuevalueWithCGPoint:CGPointMake(self.center.x-5, self.center.y)], [NSValuevalueWithCGPoint:CGPointMake(self.center.x+5, self.center.y)], [NSValuevalueWithCGPoint:CGPointMake(self.center.x, self.center.y)], nil]; [animationKey setValues:array]; [array release]; NSArray *times = [[NSArrayalloc] initWithObjects: [NSNumbernumberWithFloat:0.1f], [NSNumbernumberWithFloat:0.2f], [NSNumbernumberWithFloat:0.3f], [NSNumbernumberWithFloat:0.4f], [NSNumbernumberWithFloat:0.5f], [NSNumbernumberWithFloat:0.6f], [NSNumbernumberWithFloat:0.7f], [NSNumbernumberWithFloat:0.8f], [NSNumbernumberWithFloat:0.9f], [NSNumbernumberWithFloat:1.0f], nil]; [animationKey setKeyTimes:times]; [times release]; [self.layeraddAnimation:animationKey forKey:@&quot;TextFieldShake&quot;]; &#125; @end //TextField的晃动:End 12.二维码图片中间添加logo1234567891011121314151617+(UIImage *)addImage:(UIImage *)image1 toImage:(UIImage *)image2&#123; UIGraphicsBeginImageContext(image1.size); //Draw image1 [image1 drawInRect:CGRectMake(0, 0, image1.size.width, image1.size.height)]; //Draw image2 [image2 drawInRect:CGRectMake((image1.size.width - 60)/ 2, (image1.size.height - 60)/2, 60, 60)]; UIImage *resultImage=UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return resultImage;&#125; 13.定义枚举的几种方法1234567891011121314151617181920方法一typedef NS_ENUM(NSInteger, enumCellButtonIndex)&#123; eCBIFirst, eCBISecond,&#125;;方法二typedef enum &#123; commonTag, differentTag, noCommonTag &#125;SortedTag;方法三typedef enum : NSUInteger &#123; eQDTabViewTypeTop, eQDTabViewTypeBottom, eQDTabViewTypeBottomHideBar&#125; QDTabViewType; 14.KVO解决特殊字段（与关键词一样的敏感词）123456-(void)setValue:(id)value forUndefinedKey:(NSString *)key &#123; if ([key isEqualToString:@&quot;id&quot;]) &#123; self.ID = value; &#125; &#125; 15.TabBar上添加消息提示小红点1234567891011121. 如果有数字，直接使用 viewController.tabBarItem.badgeValue = @&quot;1&quot;;2. 没有数字，自己往tabbar加subView。 需要注意的是坐标x，y一定要是整数，否则会有模糊。 UIImageView *dotImage = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;personinfo_unread@2x.png&quot;]]; dotImage.backgroundColor = [UIColor clearColor]; dotImage.tag = RED_DOT_TAG; CGRect tabFrame = tabbarController.tabBar.frame; CGFloat x = ceilf(0.94 * tabFrame.size.width); CGFloat y = ceilf(0.2 * tabFrame.size.height); dotImage.frame = CGRectMake(x, y, 6, 6); [tabbarController.tabBar addSubview:dotImage]; [dotImage release]; 16.让程序在后台较长久的运行1234567891011121314151617181920212223// AppDelegate.h文件@property (assign, nonatomic) UIBackgroundTaskIdentifier backgroundUpdateTask;// AppDelegate.m文件- (void)applicationDidEnterBackground:(UIApplication *)application&#123; [self beingBackgroundUpdateTask]; // 在这里加上你需要长久运行的代码 [self endBackgroundUpdateTask];&#125;- (void)beingBackgroundUpdateTask&#123; self.backgroundUpdateTask = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123; [self endBackgroundUpdateTask]; &#125;];&#125;- (void)endBackgroundUpdateTask&#123; [[UIApplication sharedApplication] endBackgroundTask: self.backgroundUpdateTask]; self.backgroundUpdateTask = UIBackgroundTaskInvalid;&#125; 17.几种小的概念和方法1234567891011121314 1、sleep [NSThread sleepForTimeInterval:4]; 2、活动指示器控件 UIActivityIndicatorView 3、 _cmd的使用 _cmd是iOS内置变量，始终指向当前方法的selector 4、状态加入事件通知中心 [center addObserver:self selector:@selector(applicationWillResignActive) name:UIApplicationWillResignActiveNotification object:nil]; 5、用NSUserDefault保存用户数据 使用方法： 保存： NSInteger selectedIndex = self.segmentedControl.selectedSegmentIndex; [[NSUserDefaults standardUserDefaults] setInteger:selectedIndex forKey:@&quot;selectedIndex&quot;]; 取出： NSNumber *indexNumber = indexNumber = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;selectedIndex&quot;]; if (indexNumber) &#123; NSInteger selectedIndex = [indexNumber intValue]; self.segmentedControl.selectedSegmentIndex = selectedIndex;&#125; 18.有三种方式可以引入静态库文件1234567第一种方式：直接将对应平台的.a文件拖拽至Xcode工程左侧的Groups&amp;Files中，缺点是每次在真机和模拟器编译时都需要重新添加.a文件；第二种方式：使用lipo命令将设备和模拟器的.a合并成一个通用的.a文件，将合并后的通用.a文件拖拽至工程中即可，具体命令如下： lipo -create Release-iphoneos/libbaidumapapi.a Release-iphonesimulator/libbaidumapapi.a -output libbaidumapapi.a第三种方式：1. 将API的libs文件夹拷贝到您的Application工程根目录下2. 在Xcode的Project -&gt; Edit Active Target -&gt; Build -&gt; Linking -&gt; Other Linker Flags中添加-ObjC3. 设置静态库的链接路径，在Xcode的Project -&gt; Edit Active Target -&gt; Build -&gt; Search Path -&gt; Library Search Paths中添加您的静态库目录，比如&quot;$(SRCROOT)/../libs/Release$(EFFECTIVE_PLATFORM_NAME)&quot;，$(SRCROOT)宏代表您的工程文件目录，$(EFFECTIVE_PLATFORM_NAME)宏代表当前配置是OS还是simulator注:静态库中采用ObjectC++实现，因此需要您保证您工程中至少有一个.mm后缀的源文件(您可以将任意一个.m后缀的文件改名为.mm)，或者在工程属性中指定编译方式，即将Xcode的Project -&gt; Edit Active Target -&gt; Build -&gt; GCC4.2 - Language -&gt; Compile Sources As设置为&quot;Objective-C++&quot; 19.SDWebImage清除缓存123清除缓存：[[SDImageCache sharedImageCache] clearDisk];[[SDImageCache sharedImageCache] clearMemory]; 20.view加阴影1234view.layer.shadowOpacity = 0.5;// 阴影透明度view.layer.shadowColor = [UIColor grayColor].CGColor;// 阴影的颜色view.layer.shadowRadius = 3;// 阴影扩散的范围控制view.layer.shadowOffset = CGSizeMake(1, 1);// 阴影的范围 21.将view加到UIWindow上123UIWindow* currentWindow = [UIApplication sharedApplication].keyWindow;[currentWindow addSubview:drawView];_drawView = drawView; 22.AES加密解密。123456789// NSData+AES256.h#import &lt;Foundation/Foundation.h&gt; #import &lt;CommonCrypto/CommonDigest.h&gt; #import &lt;CommonCrypto/CommonCryptor.h&gt; @interface NSData(AES256)- (NSData *)aes256_encrypt:(NSString *)key;- (NSData *)aes256_decrypt:(NSString *)key;@end 123456789101112131415161718192021222324252627282930313233343536373839404142// NSData+AES256.m//#import &quot;NSData+AES256.h&quot;@implementation NSData (AES256)/** 加密 */- (NSData*)aes256_encrypt:(NSString *)key&#123;char keyPtr[kCCKeySizeAES256 + 1];bzero(keyPtr, sizeof(keyPtr));[key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];NSUInteger dataLength = [self length];size_t bufferSize = dataLength + kCCBlockSizeAES128;void *buffer = malloc(bufferSize);size_t numBytesEncrypted = 0;CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128, kCCOptionPKCS7Padding | kCCOptionECBMode, keyPtr, kCCBlockSizeAES128, NULL, [self bytes], dataLength, buffer, bufferSize, &amp;numBytesEncrypted);if (cryptStatus == kCCSuccess) &#123;return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];&#125;free(buffer);return nil;&#125;/** 解密 */- (NSData*)aes256_decrypt:(NSString *)key&#123;char keyPtr[kCCKeySizeAES256 + 1];bzero(keyPtr, sizeof(keyPtr));[key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];NSUInteger dataLength = [self length];size_t bufferSize = dataLength + kCCBlockSizeAES128;void* buffer = malloc(bufferSize);size_t numBytesDecrypted = 0;CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt, kCCAlgorithmAES128, kCCOptionPKCS7Padding | kCCOptionECBMode, keyPtr, kCCBlockSizeAES128, NULL, [self bytes], dataLength, buffer, bufferSize, &amp;numBytesDecrypted);if (cryptStatus == kCCSuccess) &#123;return [NSData dataWithBytesNoCopy:buffer length:numBytesDecrypted];&#125;free(buffer);return nil;&#125;@end 22.GCD异步123456dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;//通知主线程刷新dispatch_async(dispatch_get_main_queue(), ^&#123;//回调或者说是通知主线程刷新，&#125;);&#125;); 23.头部图片下拉放大12345678-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; CGFloat heightWidthRatio = VideoHeaderHeight/ScreenWidth; CGRect frame = self.headerView.frame; frame.origin.y = offsetY; frame.origin.x = offsetY/heightWidthRatio/2; frame.size.height = -offsetY+VideoHeaderHeight; frame.size.width=(-offsetY+VideoHeaderHeight)/heightWidthRatio;&#125; 24.获取版本号，DisPlayName等1234NSDictionary *infoDict = [[NSBundle mainBundle] infoDictionary]; _nameLabel.text = [infoDict objectForKey:@&quot;CFBundleDisplayName&quot;]; _versionLabel.text = [NSString stringWithFormat:@&quot;版本号: V%@&quot;,[infoDict objectForKey:@&quot;CFBundleShortVersionString&quot;]]; _rightsLabel.text = [NSString stringWithFormat:@&quot;%@ Jucailife.cn京ICP备 15058272&quot;,[[NSDate date] year]]; 25.常用监听事件 12345**键盘**//键盘出现时[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWasShown:) name:UIKeyboardWillShowNotification object:nil];//键盘收回时[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil]; 12345678910**TextField**//适用场景，打字时弹出suggestion//TextField 编辑状态时(通知)[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textFieldChanged:) name:UITextFieldTextDidChangeNotification object:textField];//或者 addTargetUIControlEventEditingDidBegin = 1 &lt;&lt; 16,//1 &lt;&lt; 17 代表:2的17次方 UIControlEventEditingChanged = 1 &lt;&lt; 17,//1 &lt;&lt; 18 代表:2的18次方UIControlEventEditingDidEnd = 1 &lt;&lt; 18,//1 &lt;&lt; 19 代表:2的19次方UIControlEventEditingDidEndOnExit = 1 &lt;&lt; 19,[field addTarget:self action:@selector(textFieldDidChanged) forControlEvents:UIControlEventEditingDidBegin | UIControlEventValueChanged | UIControlEventEditingDidEnd]; 26.监听ScrollView的滚动 1234567891011121314151617181920- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123;//偏移量 CGFloat offsetY = scrollView.contentOffset.y;if (offsetY &gt; 0) &#123; //往上滑&#125;else &#123;//往下滑&#125;//加速度 UIPanGestureRecognizer* pan = scrollView.panGestureRecognizer;CGFloat velocity = [pan velocityInView:scrollView].y;if (velocity&lt;-5) &#123; //上&#125;else if (velocity&gt;5) &#123; //下&#125;&#125; 27.字符串编码123456789101112有的时候咱们会碰见字符串里有一些特殊字符在转成URL的时候 会出现转换不了的情况，这个时候需要对字符串进行编码9.0以前使用stringByAddingPercentEscapesUsingEncoding9.0之后使用stringByAddingPercentEncodingWithAllowedCharactersNSString *resourcePath = @&quot;http://www.baidu.com?tickets=[&#123;\\&quot;num\\&quot;:\\&quot;1\\&quot;,\\&quot;priceId\\&quot;:\\&quot;8a82824756\\&quot;&#125;]&quot;; NSString *encodePath ;if (!IOS7_OR_LATER) &#123; encodePath = [resourcePath stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];&#125;else&#123; encodePath = [resourcePath stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet characterSetWithCharactersInString:@&quot;`#%^&#123;&#125;\\&quot;[]|\\\\&lt;&gt; &quot;].invertedSet];&#125; 28.ScrollView的ContentOffSet 29.ImageView填充方式。 30.绘制一条虚线。1234567891011121314151617181920212223242526/* **lineFrame: 虚线的frame **length: 虚线中短线的宽度 **spacing: 虚线中短线之间的间距 **color: 虚线中短线的颜色*/+(UIView *)creatDashedLineWithFrame:(CGRect)lineFrame lineLenght:(int)length lineSpacing:(int)spacing lineColor:(UIColor *)color&#123; UIView *dashLine = [[UIView alloc]initWithFrame:lineFrame]; dashLine.backgroundColor = [UIColor clearColor]; CAShapeLayer *shapeLayer = [CAShapeLayer layer]; [shapeLayer setBounds:dashLine.bounds]; [shapeLayer setPosition:CGPointMake(CGRectGetWidth(dashLine.frame)/2, CGRectGetHeight(dashLine.frame))]; [shapeLayer setFillColor:[UIColor clearColor].CGColor]; [shapeLayer setStrokeColor:color.CGColor]; [shapeLayer setLineWidth:CGRectGetHeight(dashLine.frame)]; [shapeLayer setLineJoin:kCALineJoinRound]; [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:length],[NSNumber numberWithInt:spacing],nil]]; CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, NULL, 0, 0); CGPathAddLineToPoint(path, NULL, CGRectGetWidth(dashLine.frame), 0); [shapeLayer setPath:path]; CGPathRelease(path); [dashLine.layer addSublayer:shapeLayer]; return dashLine;&#125; 31. 播放视频。1234567891011121314151617181920212223#import &lt;MediaPlayer/MediaPlayer.h&gt;// =================================================#pragma mark - 播放视频// =================================================+(void)playVideoWithUrl:(NSString *)url andController:(UIViewController *)controller&#123; MPMoviePlayerViewController *playerVC = [[MPMoviePlayerViewController alloc] initWithContentURL:[NSURL URLWithString:url]]; playerVC.moviePlayer.movieSourceType = MPMovieSourceTypeFile; // playerVC.moviePlayer.repeatMode = MPMovieRepeatModeOne; [controller presentMoviePlayerViewControllerAnimated:playerVC]; &#125;+(void)playVideoWithLocalPath:(NSString *)localDocumentName andController:(UIViewController *)controller&#123; NSString *path = [[NSBundle mainBundle] pathForResource:localDocumentName ofType:nil]; NSURL *url = [[NSURL alloc] initFileURLWithPath:path]; MPMoviePlayerViewController *playerVC = [[MPMoviePlayerViewController alloc] initWithContentURL:url]; playerVC.moviePlayer.movieSourceType = MPMovieSourceTypeFile; // playerVC.moviePlayer.repeatMode = MPMovieRepeatModeOne; [controller presentMoviePlayerViewControllerAnimated:playerVC];&#125; 32. iPhone屏幕尺寸、分辨率及适配。 看这个大神的帖子足够 33. 验证邮箱、电话、和QQ 1234567891011121314151617181920212223242526272829- (BOOL) validateEmail:(NSString *)email&#123;NSString *emailRegex = @&quot;[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\\\\\.[A-Za-z]&#123;2,4&#125;&quot;;NSPredicate *emailTest = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, emailRegex];return [emailTest evaluateWithObject:email];&#125;//手机号码验证- (BOOL)validateMobile:(NSString *)phone&#123;NSString *MOBILE = @&quot;^1[34578]\\\\\\\\d&#123;9&#125;$&quot;;NSPredicate *regexTestMobile = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,MOBILE];if ([regexTestMobile evaluateWithObject:phone]) &#123;return YES;&#125;else &#123;return NO;&#125;&#125;//QQ号码验证- (BOOL)validateQQ:(NSString *)qq&#123;NSString *QQ = @&quot;[1-9][0-9]&#123;4,&#125;&quot;;NSPredicate *regexTestQQ = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,QQ];if ([regexTestQQ evaluateWithObject:qq]) &#123;return YES;&#125;else &#123;return NO;&#125;&#125; 34. UISegmentedControl（直接拷来用）12345678910111213141516171819-(UISegmentedControl *)segementControl&#123;if (_segementControl == nil) &#123;UISegmentedControl *segmentedControl = [[UISegmentedControl alloc] initWithItems:@[@&quot;餐馆&quot;, @&quot;菜单&quot;]];segmentedControl.frame = CGRectMake((ScreenWidth-150)/2, 10, 150, 30);// 设置进入页面后的所处的位置segmentedControl.selectedSegmentIndex = 0;//选中的颜色segmentedControl.tintColor = [UIColor redColor];[segmentedControl addTarget:self action:@selector(segmentedControlValueChanged:) forControlEvents:UIControlEventValueChanged];[self.segementWrapView addSubview:segmentedControl];_segementControl = segmentedControl;&#125;return _segementControl;&#125;- (void)segmentedControlValueChanged:(UISegmentedControl *) segmentedControl &#123;if (0 == segmentedControl.selectedSegmentIndex) &#123;&#125;&#125; 35. iOS一键加群123456789- (BOOL)joinGroup:(NSString *)groupUin key:(NSString *)key&#123;NSString *urlStr = [NSString stringWithFormat:@&quot;mqqapi://card/show_pslcard? src_type=internal&amp;version=1&amp;uin=%@&amp;key=%@&amp;card_type=group&amp;source=external&quot;, @&quot;240555441&quot;,@&quot;60d319547ddffeacefe646f0d273e988a26dc70065bdedfd6a63c484e3c353c0&quot;];NSURL *url = [NSURL URLWithString:urlStr];if([[UIApplication sharedApplication] canOpenURL:url])&#123;[[UIApplication sharedApplication] openURL:url];return YES;&#125;else return NO;&#125; 36.CLLocation的一些黑魔法 (1).pausesLocationUpdatesAutomatically locationManager.pausesLocationUpdatesAutomatically = NO;贴上一段官网对这个属性的描述：Allowing the location manager to pause updates can improve battery life on the target device without sacrificing location data. When this property is set to YES, the location manager pauses updates (and powers down the appropriate hardware) at times when the location data is unlikely to change. For example, if the user stops for food while using a navigation app, the location manager might pause updates for a period of time. You can help the determination of when to pause location updates by assigning a value to the activityTypeproperty. 大致的意思就是如果这个属性设置成YES（默认的也是YES），那么系统会检测如果设备有一段时间没有移动，就会自动停掉位置更新服务。这里需要注意的是，一旦定位服务停止了，只有当用户再次开启App的时候定位服务才会重新启动。这里的一段时间是系统自动判定的，可以通过设置activityTypeproperty这个属性来决定这个时间的长短。API的意思是，类似导航类的App,系统检验的时间会稍长一点，想运动类的App，就会比导航类的短一点。但是具体时间还是由系统来决定。 (2).headingFilter123456locationManager.headingFilter = 45;//设置只有当设备方向的改变值超过该属性值时才激发delegate的方法。- (void)locationManager:(CLLocationManager *)manager didUpdateHeading:(CLHeading *)newHeading&#123;MKAnnotationView *anv = [_mapView viewForAnnotation:_mapView.userLocation];anv.transform = CGAffineTransformMakeRotation(newHeading.magneticHeading/360.0*2*M_PI);&#125; (3).deferredUpdates默认地，定位服务的代理会每秒钟都更新一次位置，这样对电池的消耗量会特别地大。除了设置pausesLocationUpdatesAutomatically这个属性以外，iOS还提供了DeferredUpdates的机制。123官方API文档：- (void)allowDeferredLocationUpdatesUntilTraveled:(CLLocationDistance)distance timeout:(NSTimeInterval)timeout distance：The distance (in meters) from the current location that must be travelled before event delivery resumes. To specify an unlimited distance, pass the CLLocationDistanceMaxconstant.timeout：The amount of time (in seconds) from the current time that must pass before event delivery resumes. To specify an unlimited amount of time, pass the CLTimeIntervalMax constant. 就是你可以设置让系统每隔多远或者每隔多长时间更新一次位置。注意是“或”的关系，满足一个就会更新。使用这个方法有很多要注意的地方：desiredAccuracy必须设置成kCLLocationAccuracyBestdistanceFilter必须设置成kCLErrorDeferredDistanceFiltered必须能够使用GPS进行定位（而不仅仅是移动数据或者Wi-Fi）非常重要的一点，DeferredUpdates只会出现在设备进入低耗电量的状态，App运行在前台或者设备连接在Xcode上正在调试是不会触发的。（所以不可能在Debug的时候打印Log来检验，要调试的话，需要写一些Log存在本地的数据库） 37.真机中.Plist文件的读写.Plist文件的读写默认真机不管用,因为在真机环境下,App在Xcode中的Resources文件夹都是不可写的.所以我们要在App第一次运行时将需要修改且长久保存的数据放到Document目录下:12345- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123;[self initDataFile];return YES；&#125; 123456789101112131415161718//在Document目录中初始化地图数据文件,因为该目录下文件可写且可以持久保存-(void)initDataFile&#123;NSString *docPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];//取得目标文件路径NSString *path = [docPath stringByAppendingPathComponent:@&quot;titleList.plist&quot;];NSFileManager *fm = [NSFileManager defaultManager];//如果目标文件不存在说明是App第一次运行,需要将相关可修改数据文件拷贝至目标路径.if (![fm fileExistsAtPath:path]) &#123;NSError *error = nil;//取得源文件路径NSString *paths = [[NSBundle mainBundle] pathForResource:@&quot;titleList&quot; ofType:@&quot;plist&quot;];if (![fm copyItemAtPath:paths toPath:path error:&amp;error]) &#123;&#125;&#125;&#125; 12345678//.Plist文件的读写NSArray *arrPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *strDocBase = ([arrPaths count] &gt; 0) ? [arrPaths objectAtIndex:0] : nil;_path = [strDocBase stringByAppendingPathComponent:@&quot;titleList.plist&quot;];//读取数据NSArray *data = [NSArray arrayWithContentsOfFile:_path];//写入数据[_datas writeToFile:_path atomically:YES]; 38.UITableView的Group样式下顶部空白处理123//分组列表头部空白处理UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, 0.1)];self.tableView.tableHeaderView = view; 39.获取某个view所在的控制器12345678910111213- (UIViewController *)viewController&#123;UIViewController *viewController = nil;UIResponder *next = self.nextResponder;while (next)&#123;if ([next isKindOfClass:[UIViewController class]])&#123;viewController = (UIViewController *)next;break;&#125;next = next.nextResponder;&#125;return viewController;&#125; 40.两种方法删除NSUserDefaults所有记录1234567891011121314//方法一NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];//方法二- (void)resetDefaults&#123;NSUserDefaults * defs = [NSUserDefaults standardUserDefaults];NSDictionary * dict = [defs dictionaryRepresentation];for (id key in dict)&#123;[defs removeObjectForKey:key];&#125;[defs synchronize];&#125; 41.获取图片某一点的颜色12345678910111213141516171819202122232425262728- (UIColor*) getPixelColorAtLocation:(CGPoint)point inImage:(UIImage *)image&#123;UIColor* color = nil;CGImageRef inImage = image.CGImage;CGContextRef cgctx = [self createARGBBitmapContextFromImage:inImage];if (cgctx == NULL) &#123;return nil; /* error */&#125;size_t w = CGImageGetWidth(inImage);size_t h = CGImageGetHeight(inImage);CGRect rect = &#123;&#123;0,0&#125;,&#123;w,h&#125;&#125;;CGContextDrawImage(cgctx, rect, inImage);unsigned char* data = CGBitmapContextGetData (cgctx);if (data != NULL) &#123;int offset = 4*((w*round(point.y))+round(point.x));int alpha = data[offset];int red = data[offset+1];int green = data[offset+2];int blue = data[offset+3];color = [UIColor colorWithRed:(red/255.0f) green:(green/255.0f) blue:(blue/255.0f) alpha:(alpha/255.0f)];&#125;CGContextRelease(cgctx);if (data) &#123;free(data);&#125;return color;&#125; 42.禁止锁屏 1234默认情况下，当设备一段时间没有触控动作时，iOS会锁住屏幕。但有一些应用是不需要锁屏的，比如视频播放器。[UIApplication sharedApplication].idleTimerDisabled = YES;或[[UIApplication sharedApplication] setIdleTimerDisabled:YES]; 43.模态推出透明界面1234567891011UIViewController *vc = [[UIViewController alloc] init];UINavigationController *na = [[UINavigationController alloc] initWithRootViewController:vc];if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8.0)&#123;na.modalPresentationStyle = UIModalPresentationOverCurrentContext;&#125;else&#123;self.modalPresentationStyle=UIModalPresentationCurrentContext;&#125;[self presentViewController:na animated:YES completion:nil]; 44.iOS 获取汉字的拼音123456789101112+ (NSString *)transform:(NSString *)chinese&#123;//将NSString装换成NSMutableStringNSMutableString *pinyin = [chinese mutableCopy];//将汉字转换为拼音(带音标)CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformMandarinLatin, NO);NSLog(@&quot;%@&quot;, pinyin);//去掉拼音的音标CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformStripCombiningMarks, NO);NSLog(@&quot;%@&quot;, pinyin);//返回最近结果return pinyin;&#125; 45.判断对象是否遵循了某协议1234if ([self.selectedController conformsToProtocol:@protocol(RefreshPtotocol)])&#123;[self.selectedController performSelector:@selector(onTriggerRefresh)];&#125; 46.判断view是不是指定视图的子视图 1BOOL isView = [textView isDescendantOfView:self.view]; 47.取消UICollectionView的隐式动画123456789101112131415161718192021UICollectionView在reloadItems的时候，默认会附加一个隐式的fade动画，有时候很讨厌，尤其是当你的cell是复合cell的情况下(比如cell使用到了UIStackView)。下面几种方法都可以帮你去除这些动画//方法一[UIView performWithoutAnimation:^&#123;[collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];&#125;];//方法二[UIView animateWithDuration:0 animations:^&#123;[collectionView performBatchUpdates:^&#123;[collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];&#125; completion:nil];&#125;];//方法三[UIView setAnimationsEnabled:NO];[self.trackPanel performBatchUpdates:^&#123;[collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];&#125; completion:^(BOOL finished) &#123;[UIView setAnimationsEnabled:YES];&#125;]; 后话：附上之前写的文章，欢迎指正：荼菜的iOS笔记–Core Animation 核心动画 荼菜的iOS笔记–UIView的几个Block动画荼菜的iOS笔记–UITableViewCell的各种操作（刷新、插入、删除、动画）荼菜的iOS笔记–一张图记住所有git命令行操作。荼菜的iOS笔记–一张图告诉你程序员需要知道的这些网站。荼菜的iOS笔记–图片裁剪黑魔法。荼菜的iOS笔记–iOS自动打包脚本（Python） 荼菜的iOS笔记–我的编码规范参考。荼菜的iOS笔记–iOS基础优秀博客总结ToDoList荼菜的iOS笔记–Xcode Tips当然，我还写过诗。。。光。","tags":[]},{"title":"光。","date":"2017-03-02T08:51:36.000Z","path":"2017/03/02/光。/","text":"我逆着光走去朦胧全是人影可我看不到任何人的面孔管他呢因为我知道光的方向有你你逆着它你认得出我","tags":[]},{"title":"荼菜的iOS笔记--UITableViewCell的各种操作（刷新、插入、删除、动画）","date":"2017-03-02T08:50:06.000Z","path":"2017/03/02/荼菜的iOS笔记-UITableViewCell的各种操作（刷新、插入、删除、动画）/","text":"前言：最近在做一个聊天的对话机器人应用，主界面就是一个tableView，所以难免用到了对cell的各种操作。下边代码全部为从工程中拷贝出来的，以备自己下次使用，由于是公司的工程，故不能贴出Demo，但如有有疑问还可以问我，必定有问必答。 ##一、刷新数据源123456//刷新整个Section- (void)reloadDataBySection&#123;NSIndexSet* indexSet = [NSIndexSet indexSetWithIndex:0];[self.tableView reloadSections:indexSet withRowAnimation:UITableViewRowAnimationTop];&#125; 123456//通过刷新某个Section的每一个Row来刷新Section - (void)reloadDataBySection&#123;NSIndexSet* indexSet = [NSIndexSet indexSetWithIndex:0];[self.tableView reloadSections:indexSet withRowAnimation:UITableViewRowAnimationTop];&#125; 12345//刷新单行- (void)reloadSingleRow&#123;[self.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];&#125; ##二、插入数据源在调用insertRowsAtIndexPaths和deleteRowsAtIndexPaths的时候一定要先改变数据源，在调用上述函数，不然会产生crash。 12@property (nonatomic,strong) NSMutableArray *indexPathsArray;_indexPathsArray = [NSMutableArray array]; 1234567891011121314151617#pragma mark -- 聊天界面数据刷新//删除最后一行waiting气泡-(void)deleteData&#123;[_datas removeLastObject];[_indexPathsArray addObject:[NSIndexPath indexPathForItem:_datas.count inSection:0]];[self.tableView deleteRowsAtIndexPaths:_indexPathsArray withRowAnimation:UITableViewRowAnimationFade];[_indexPathsArray removeAllObjects];&#125;//新增一条消息气泡-(void)insertData&#123;[ws.datas addObject:model];[_indexPathsArray addObject:[NSIndexPath indexPathForItem:_datas.count-1 inSection:0]];[self.tableView insertRowsAtIndexPaths:_indexPathsArray withRowAnimation:UITableViewRowAnimationLeft];[_indexPathsArray removeAllObjects];&#125; 12345//插入一个Section-(void)insertData&#123;NSInteger datasCount = _datas.count&gt;1?_datas.count-1:0;[self.tableView insertSections:[NSIndexSet indexSetWithIndex:datasCount] withRowAnimation:UITableViewRowAnimationTop];&#125; ##三、获取cell所在frame 12345678910111213//应用场景：点击Cell后要执行动画，动画需要从当前cell的frame开始变化的场景- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123;CGRect cellFrameInTableView = [tableView rectForRowAtIndexPath:indexPath];CGRect cellFrameInSuperview = [tableView convertRect:cellFrameInTableView toView:[tableView superview]];DetailViewController* detailViewController = [[DetailViewController alloc] initWithNibName:@&quot;DetailViewController&quot; bundle:nil];NSMutableDictionary* dict = [self.arrayForPlaces objectAtIndex:indexPath.row];detailViewController.dictForData = dict;detailViewController.yOrigin = cellFrameInSuperview.origin.y;[self.navigationController pushViewController:detailViewController animated:NO];[detailViewController release];[tableView deselectRowAtIndexPath:indexPath animated:YES];&#125; 123456//同理，下边为获取**collectionViewCell**相对屏幕和相对collectionView的frameCGRect cellFrame = [[collectionView cellForItemAtIndexPath:indexPath] frame];CGRect cellFrameInSuperView = [collectionView convertRect:cellFrame toView:collectionView];CGRect cellFrameInScreen = [collectionView convertRect:cellFrame toView:self];NSLog(@&quot;frameInSuperView --%f &quot;,cellFrameInSuperView.origin.x);NSLog(@&quot;cellReal --%f &quot;,cellFrameInScreen.origin.x); ##四、cell的一些动画 cell进入时动画，依次往上拱 12345678910111213141516171819-(void)startTableViewAnimation&#123;[self.tableView reloadData];NSArray *visibleCells=self.tableView.visibleCells;CGFloat tableHeight=self.tableView.bounds.size.height;for (UITableViewCell *cell in visibleCells) &#123;cell.transform = CGAffineTransformMakeTranslation(0, tableHeight);&#125;NSInteger index=0;for (UITableViewCell *cell in visibleCells) &#123;cell.transform = CGAffineTransformMakeTranslation(0, tableHeight);[UIView animateWithDuration:1.0 delay:0.01*index usingSpringWithDamping:0.8 initialSpringVelocity:0 options:UIViewAnimationOptionTransitionNone animations:^&#123;cell.transform = CGAffineTransformMakeTranslation(0, 0);&#125; completion:nil];index += 1;&#125;&#125; cell进入时动画，cell放大 12345678910-(void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath&#123;//设置Cell的动画效果为3D效果//设置x和y的初始值为0.1；cell.layer.transform = CATransform3DMakeScale(0.1, 0.1, 1);//x和y的最终值为1[UIView animateWithDuration:1 animations:^&#123;cell.layer.transform = CATransform3DMakeScale(1, 1, 1);&#125;];&#125; cell出现时，由斜变正 12345678910111213141516- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath &#123;// 从锚点位置出发，逆时针绕 Y 和 Z 坐标轴旋转90度CATransform3D transform3D = CATransform3DMakeRotation(M_PI_2, 0.0, 1.0, 1.0);// 定义 cell 的初始状态cell.alpha = 0.0;cell.layer.transform = transform3D;cell.layer.anchorPoint = CGPointMake(0.0, 0.5); // 设置锚点位置；默认为中心点(0.5, 0.5)// 定义 cell 的最终状态，执行动画效果[UIView animateWithDuration:0.5 animations:^&#123;cell.alpha = 1.0;cell.layer.transform = CATransform3DIdentity;CGRect rect = cell.frame;rect.origin.x = 0.0;cell.frame = rect;&#125;];&#125; cell删除动画 1234567[_tableViews deleteRowsAtIndexPaths:@[cell.indexPath] withRowAnimation:UITableViewRowAnimationLeft];[UIView animateWithDuration:0.3 animations:^&#123;cell.contentView.center = CGPoint(-width / 2, height / 2);&#125; completion:^(BOOL finished) &#123;[self.tableView deleteRowsAtIndexPaths:xxx withRowAnimation:UITableViewRowAnimationTop];&#125;]; cell依次插入动画 123456789101112131415161718192021222324252627282930313233343536@property(nonatomic,strong)NSMutableArray *indesPaths;@property (nonatomic,assign)int DatNum;@property(nonatomic,strong) NSTimer * timer;- (void)viewDidLoad &#123;[super viewDidLoad];[self configInit];[self loadData];[self startTableViewAnimation];self.DatNum = -1;NSMutableArray *indexPaths = @[].mutableCopy;self.indesPaths = indexPaths;self.timer = [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(charusell) userInfo:nil repeats:YES];&#125;-(void)charusell&#123;self.DatNum = self.DatNum +1;if (self.DatNum &lt; self.allDatas.count) &#123;[self.indesPaths addObject:[NSIndexPath indexPathForItem:self.DatNum inSection:0]];[self.tableView insertRowsAtIndexPaths:self.indesPaths withRowAnimation:UITableViewRowAnimationTop];[self.indesPaths removeAllObjects];&#125;else&#123;[self.timer invalidate];//记得当不用这个定时器的时候要销毁.self.timer = nil;&#125;&#125;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;// return _allDatas.count;return self.DatNum+1;&#125; 后话：附上之前写的文章，欢迎指正：荼菜的iOS笔记–Core Animation 核心动画 荼菜的iOS笔记–UIView的几个Block动画荼菜的iOS笔记–一些实用功能。荼菜的iOS笔记–一张图记住所有git命令行操作。荼菜的iOS笔记–一张图告诉你程序员需要知道的这些网站。荼菜的iOS笔记–图片裁剪黑魔法。荼菜的iOS笔记–iOS自动打包脚本（Python） 荼菜的iOS笔记–我的编码规范参考。荼菜的iOS笔记–iOS基础优秀博客总结ToDoList荼菜的iOS笔记–Xcode Tips当然，我还写过诗。。。光。","tags":[]},{"title":"荼菜的iOS笔记--一张图记住所有git命令行操作。","date":"2017-03-02T08:47:57.000Z","path":"2017/03/02/荼菜的iOS笔记-一张图记住所有git命令行操作。/","text":"附上之前记录的笔记，留作纪念：12克隆代码：git clone -b Dev git@github.com:公司/xxxx.git 12345提交代码：* cd Desktop/jucai-ios-app //进入工程目录* git status //查看分支状体* git add . //添加所有* git commit -m &quot;Release Version&quot; // 提交修改说明 12345删除分支：* cd Desktop/jucai-ios-app //进入工程目录* git branch //查看分支列表* git branch -D EasySearch //删除本地分支* git push origin :EasySearch //删除远程分支 123456合并分支：* cd Desktop/jucai-ios-app //进入需要合并的分支* git branch //查看分支列表* git merge branchName //与branchName合并* ESC + : wq* git status -s // 查看冲突 有了上面那种图，这些都不用看了。 后话：附上之前写的文章，欢迎指正：荼菜的iOS笔记–Core Animation 核心动画 荼菜的iOS笔记–UIView的几个Block动画荼菜的iOS笔记–一些实用功能。荼菜的iOS笔记–UITableViewCell的各种操作（刷新、插入、删除、动画）荼菜的iOS笔记–一张图告诉你程序员需要知道的这些网站。荼菜的iOS笔记–图片裁剪黑魔法。荼菜的iOS笔记–iOS自动打包脚本（Python） 荼菜的iOS笔记–我的编码规范参考。荼菜的iOS笔记–iOS基础优秀博客总结ToDoList荼菜的iOS笔记–Xcode Tips当然，我还写过诗。。。光。","tags":[]},{"title":"荼菜的iOS笔记--图片裁剪黑魔法。","date":"2017-03-02T08:45:50.000Z","path":"2017/03/02/荼菜的iOS笔记-图片裁剪黑魔法。/","text":"前言：最近在做一款对话交互式的美食机器人应用，目前内测阶段，效果如上图。最近闲暇之余会把期间总结的一些知识点写下来，做个总结。前期有段时间困扰了我很久一个问题由于工程中的图片数据抓取自不同平台，所以图片的大小尺寸不一定，而放置图片的imageView尺寸是一定的，不作任何处理的话会导致图片拉伸变形，因此找了好久解决办法，现把它拿出来。 *图片裁剪代码：12345678910111213141516171819#import &lt;UIKit/UIKit.h&gt;#import &quot;UIImageView+WebCache.h&quot;@interface UIImageView (WebImage)/** * @author Tucai, 16-02-23 12:02:53 * * 设置能够自动裁剪的网络图，基于SDWebImage实现 * */// 模糊图渲染- (void)renderBlurredImageWithUrl:(NSString *)url placeholder:(UIImage *)placeholder completed:(imageDownloadCompletedBlock) completedBlock;//按比例缩放网络图片- (void)yg_setTrimImageWithUrl:(NSString *)url placeholderImage:(UIImage *)placeholder; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#import &quot;UIImageView+WebImage.h&quot;#import &quot;NSString+URLEncoding.h&quot;@implementation UIImageView (WebImage)#pragma mark - 模糊图渲染- (void)renderBlurredImageWithUrl:(NSString *)url placeholder:(UIImage *)placeholder completed:(imageDownloadCompletedBlock) completedBlock&#123; // 这里必须开启内存缓存 [SDWebImageManager sharedManager].imageCache.shouldCacheImagesInMemory = YES; // 渲染背景 __weak typeof(self) ws = self; [ws sd_setImageWithURL:[NSURL URLWithString:url] completed:^(UIImage *webImage, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) &#123; // 999 是一个标记 if (ws.tag != 999) &#123; UIVisualEffectView *visualView = [[UIVisualEffectView alloc] initWithFrame:ws.bounds]; UIBlurEffect *effect = [UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]; visualView.effect = effect; NSLog(@&quot;only once&quot;); [ws addSubview:visualView]; ws.tag = 999; &#125; ws.alpha =0.6; ws.image = nil; ws.image = webImage; if (completedBlock) &#123; completedBlock(webImage); &#125; &#125;];&#125;#pragma mark - 裁剪图片- (void)yg_setTrimImageWithUrl:(NSString *)url placeholderImage:(UIImage *)placeholder&#123; __weak typeof(self) ws = self; [SDWebImageManager sharedManager].imageCache.shouldCacheImagesInMemory = NO; [self sd_setImageWithURL:[NSURL URLWithString:url] placeholderImage:placeholder completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) &#123; if (image) &#123; UIImage *img=[self yg_trimImageWithImage:image]; ws.image=img; &#125;else&#123; ws.image =[self yg_trimImageWithImage:placeholder]; &#125; &#125;];&#125;-(UIImage *)yg_trimImageWithImage:(UIImage *)image&#123; //imageView的宽高比 CGFloat imageViewWidthHeightRatio =self.frame.size.width/self.frame.size.height; //屏幕分辨率// CGFloat imageScale = [[UIScreen mainScreen] scale]; CGFloat imageScale = 1; CGFloat imageWith = image.size.width*imageScale; CGFloat imageHeight =image.size.height*imageScale; //image的宽高比 CGFloat imageWidthHeightRatio =imageWith/imageHeight; CGImageRef imageRef = nil; CGRect rect; // NSLog(@&quot;\\nimageWith === %f\\nimageHeight === %f\\nImageView宽高比 == %f\\nimageScale == %f&quot;,imageWith,imageHeight,imageViewWidthHeightRatio,imageScale); if (imageWidthHeightRatio&gt;imageViewWidthHeightRatio) &#123; rect = CGRectMake((imageWith-imageHeight*imageViewWidthHeightRatio)/2, 0, imageHeight*imageViewWidthHeightRatio, imageHeight); &#125;else if (imageWidthHeightRatio&lt;imageViewWidthHeightRatio) &#123; rect = CGRectMake(0, (imageHeight-imageWith/imageViewWidthHeightRatio)/2, imageWith, imageWith/imageViewWidthHeightRatio); &#125;else &#123; rect = CGRectMake(0, 0, imageWith, imageHeight); &#125; imageRef = CGImageCreateWithImageInRect([image CGImage], rect); UIImage *res = [UIImage imageWithCGImage:imageRef scale:imageScale orientation:UIImageOrientationUp]; /** 一定要，千万要release，否则等着内存泄露吧，稍微高清点的图一张图就是几M内存，很快App就挂了 */ CGImageRelease(imageRef); return res;&#125;@end 后话：附上之前写的文章，欢迎指正： 荼菜的iOS笔记–Core Animation 核心动画 荼菜的iOS笔记–UIView的几个Block动画荼菜的iOS笔记–一些实用功能。荼菜的iOS笔记–UITableViewCell的各种操作（刷新、插入、删除、动画）荼菜的iOS笔记–一张图记住所有git命令行操作。荼菜的iOS笔记–一张图告诉你程序员需要知道的这些网站。荼菜的iOS笔记–iOS自动打包脚本（Python） 荼菜的iOS笔记–我的编码规范参考。荼菜的iOS笔记–iOS基础优秀博客总结ToDoList荼菜的iOS笔记–Xcode Tips当然，我还写过诗。。。光。","tags":[]},{"title":"荼菜的iOS笔记--Xcode Tips","date":"2017-03-02T08:44:09.000Z","path":"2017/03/02/荼菜的iOS笔记-Xcode-Tips/","text":"前言：孙源大神总结了几个 Xcode 小技巧，为方便自己查看遂自己拷贝一份 #一、快速定位方法调用者 #二、继续编译有Error的工程 #三、给@prorerty设置断点 后话：附上之前写的文章，欢迎指正：荼菜的iOS笔记–Core Animation 核心动画 荼菜的iOS笔记–UIView的几个Block动画荼菜的iOS笔记–一些实用功能。荼菜的iOS笔记–UITableViewCell的各种操作（刷新、插入、删除、动画）荼菜的iOS笔记–一张图记住所有git命令行操作。荼菜的iOS笔记–一张图告诉你程序员需要知道的这些网站。荼菜的iOS笔记–图片裁剪黑魔法。荼菜的iOS笔记–iOS自动打包脚本（Python） 荼菜的iOS笔记–我的编码规范参考。荼菜的iOS笔记–iOS基础优秀博客总结ToDoList当然，我还写过诗。。。光。","tags":[]},{"title":"荼菜的iOS笔记--iOS基础优秀博客总结ToDoList","date":"2017-03-02T08:41:46.000Z","path":"2017/03/02/荼菜的iOS笔记-iOS基础优秀博客总结ToDoList/","text":"前言：最近在总结iOS比较底层的东西，于是翻遍了各个大牛的博客，看到AidenRao总结的文章，挨个点进去看了很不错，于是又补充了些我觉得不错的文章，给自己做个备份。 #类和对象 iOS程序main函数之前发生了什么谈ObjC对象的两段构造模式从NSObject的初始化了解isa (1)深入解析ObjC中方法的结构(2)What is a meta-class in Objective-C?对象是如何初始化的深入理解Objective-C：Category #RunLoop ：YY大神(深入理解RunLoop)视频：孙源(百度)(线下分享RunLoop)RunLoop总结：RunLoop基础知识RunLoop 总结：RunLoop的应用场景（一）保证线程长久存活RunLoop 总结：RunLoop的应用场景（二）让Timer正常运转RunLoop总结：RunLoop的应用场景（三）滚动视图流畅性优化RunLoop总结：RunLoop的应用场景（四）App卡顿监测RunLoop总结：RunLoop的应用场景（五）阻止App崩溃一次 #RuntimeiOS-runtimeiOS-runtime理解iOS开发之Runtime常用示例总结深入理解Objective-C：方法缓存译:理解 Objective-C RuntimeObjective-C Runtime 1小时入门教程Method Swizzling 和 AOP 实践刨根问底：对于 self = [super init] 的思考 在objc中的一个重要的特点就是对象化。我们所用的 NSObject 这个类其实也是一个对象。如果我们初始化 NSObject *p = [[NSObject alloc] init]; ，那么 p 这个对象中在runtime时会当作一个结构体isa_t对象来处理。而其中的 isa 指针（由objc_object继承而来）会指向自身的类对象。也就是说，这里的 p.isa 是指向 NSObject （这种写法不太严格，但是可以这么描述）。同此，文中的 block 也为了模仿 对象 的结构，制作了一个isa属性。对于isa的具体细节我没有写过相关文章，但是强烈推荐学习这篇博文 runtime可以做什么？ 多继承 交换两个方法法的实现 关联对象 #GCDGCD 深入理解：第一部分GCD 深入理解：第二部分 #多线程 与 锁Objective-C中不同方式实现锁(一)Objective-C中不同方式实现锁(二)iOS中的锁iOS开发－多线程开发之线程安全篇iOS多线程-各种线程锁的简单介绍关于 @synchronized，这儿比你想知道的还要多iOS中保证线程安全的几种方式与性能对比 #并发编程Cocoa 并发编程iOS 多线程编程 —— GCD 与 NSOperation 总结 #MRC 和 ARCObjective-C 中的内存分配 #事件处理Cocoa Touch事件处理流程–响应者链iOS中的事件处理、响应者链条以及第一响应者在 Target-Action 中使用响应链 #设计模式设计模式 #动画荼菜的iOS笔记–Core Animation 核心动画 #流畅： 离屏渲染绘制像素到屏幕上 #SwiftSwift教程 #反编译(逆向)：工具 FLEXLoader #python： step 1： 两本书：《A Byte of Python》 《Learning Python》《Python核心编程 宋吉广 译》 step 2： 视频：Python 入门（imooc) step 3： 博客：菜鸟学python) #Unity3D体验第一个游戏雏形 #AFNetWorking #ResumeSampleResumeSample《招聘一个靠谱的 iOS》— 参考答案 #源码解析源码解析-Draveness #阿里巴巴hit-alibaba.github.io #拓展iOS 中armv7,armv7s,arm64,i386,x86_64 都是什么iOS开发～制作同时支持armv7,armv7s,arm64,i386,x86_64的静态库.aclang -rewrite-objc MyClass.m 执行上面的命令，将这一句重写为C代码 后话：附上之前写的文章，欢迎指正：荼菜的iOS笔记–Core Animation 核心动画 荼菜的iOS笔记–UIView的几个Block动画荼菜的iOS笔记–一些实用功能。荼菜的iOS笔记–UITableViewCell的各种操作（刷新、插入、删除、动画）荼菜的iOS笔记–一张图记住所有git命令行操作。荼菜的iOS笔记–一张图告诉你程序员需要知道的这些网站。荼菜的iOS笔记–图片裁剪黑魔法。荼菜的iOS笔记–iOS自动打包脚本（Python） 荼菜的iOS笔记–我的编码规范参考。荼菜的iOS笔记–Xcode Tips当然，我还写过诗。。。光。","tags":[]},{"title":"荼菜的iOS笔记--我的编码规范参考.","date":"2017-03-02T08:38:22.000Z","path":"2017/03/02/荼菜的iOS笔记-我的编码规范参考/","text":"前言：下面是我的编码习惯。 12345678#一、常量相对字符串字面量或数字，我们更推荐适用常量。应使用static方式声明常量，而非使用#define的方式来定义宏。例如：static NSString * const NYTAboutViewControllerCompanyName = @&quot;The New York Times Company&quot;; static const CGFloat NYTImageThumbnailHeight = 50.0;不恰当://#define CompanyName @&quot;The New York Times Company&quot;//#define thumbnailHeight 2 1234567#二、枚举类型在使用enum的时候，推荐适用最新的fixed underlying type(WWDC 2012 session 405- Modern Objective-C)规范，因为它具备更强的类型检查和代码完成功能。如：typedef NS_ENUM(NSInteger, NYTAdRequestState) &#123;NYTAdRequestStateInactive,NYTAdRequestStateLoading&#125;; 123#三、布尔变量如果一个BOOL属性使用形容词来表达，属性将忽略’is’前缀，但会强调惯用名称。 例如：@property (assign, getter=isEditable) BOOL editable; 1234567891011#四、单例在创建单例对象的共享实例时，应使用线程安全模式。如：(instancetype)sharedInstance &#123;static id sharedInstance = nil;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;sharedInstance = [[self alloc] init];&#125;);return sharedInstance;&#125; 12345678910111213141516#五、Import在类的头文件中需要引用其他的类的时候，需要用@class这个关键字，这样能减少类与类之间的依赖。如:store.h:#import &lt;Foundation/Foundation.h&gt;#import &lt;CoreData/CoreData.h&gt;@class User;@interface Store : NSManagedObject@property (nonatomic, retain) User *user;@endStore.m:#import &quot;Store.h&quot;#import &quot;User.h&quot;@implementation Store//doSomething@end 1234567891011121314#六、CGRect函数当需要获取一个CGRect矩形的x,y,width,height属性时，应使用CGGeometry函数，而非直接访问结构体成员。如：CGRect frame = self.view.frame;CGFloat x = CGRectGetMinX(frame);CGFloat y = CGRectGetMinY(frame);CGFloat width = CGRectGetWidth(frame);CGFloat height = CGRectGetHeight(frame);不恰当：CGRect frame = self.view.frame;CGFloat x = frame.origin.x;CGFloat y = frame.origin.y;CGFloat width = frame.size.width;CGFloat height = frame.size.height; 后话：附上之前写的文章，欢迎指正：荼菜的iOS笔记–Core Animation 核心动画 荼菜的iOS笔记–UIView的几个Block动画荼菜的iOS笔记–一些实用功能。荼菜的iOS笔记–UITableViewCell的各种操作（刷新、插入、删除、动画）荼菜的iOS笔记–一张图记住所有git命令行操作。荼菜的iOS笔记–一张图告诉你程序员需要知道的这些网站。荼菜的iOS笔记–图片裁剪黑魔法。荼菜的iOS笔记–iOS自动打包脚本（Python） 荼菜的iOS笔记–iOS基础优秀博客总结ToDoList荼菜的iOS笔记–Xcode Tips当然，我还写过诗。。。光。","tags":[]},{"title":"荼菜的iOS笔记--iOS自动打包","date":"2017-03-02T08:34:02.000Z","path":"2017/03/02/荼菜的iOS笔记-iOS自动打包/","text":"最近几天学Python，顺便写了个自动打包的脚本，给大家做个参考。注释和步骤代码里都写得有，使用时把工程路径换了就行。可以直接拷贝到你的.py文件里执行。当然你还可以来我的GitHub直接下载文件Python_Archiveipa 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import osimport sysimport timeimport hashlibfrom email import encodersfrom email.header import Headerfrom email.mime.text import MIMETextfrom email.utils import parseaddr, formataddrimport smtplib# 项目根目录project_path = &apos;/Users/yanggan/Desktop/jucai-ios-app&apos;# 编译成功后.app所在目录 其中&apos;/Users/yanggan/Desktop/jucai-ios-app&apos;为项目路径app_path = &apos;%s/build/Build/Products/Release-iphoneos/JuCaiShengHuo.app&apos; % (project_path)# 指定项目下编译目录build_path = &apos;build&apos;# 打包后ipa存储目录targerIPA_parth = &apos;/Users/yanggan/Desktop&apos;# 项目名称project_name = &apos;JuCaiShengHuo&apos;# ipafilenameipa_filename = &apos;JuCaiShengHuo.ipa&apos;# firm的api token 需要自己申请账号，申请地址-&gt; http://fir.im/appsfir_api_token = &apos;4a0d2512c33d0a10ca0e59dbd04b45b0&apos;# 需要自己配置邮件端口号，服务器和对方邮箱地址#from_addr = &quot;邮件地址&quot;#password = &quot;邮件密码&quot;#smtp_server = &quot;smtp.服务器&quot;#to_addr = &quot;对方邮件地址&quot;# 清理项目 创建build目录def clean_project_mkdir_build(): os.system(&apos;cd %s;xcodebuild clean&apos; % project_path) # clean 项目 os.system(&apos;cd %s;mkdir build&apos; % project_path)def build_project(): print(&apos;build release start&apos;) os.system (&apos;xcodebuild -list&apos;) os.system (&apos;cd %s;xcodebuild -workspace %s.xcworkspace -scheme %s -configuration release -derivedDataPath %s ONLY_ACTIVE_ARCH=NO || exit&apos; % (project_path,project_name,project_name,build_path))# CONFIGURATION_BUILD_DIR=./build/Release-iphoneos# 打包ipa 并且保存在桌面def build_ipa(): global ipa_filename# ipa_filename = time.strftime(&apos;xx_%Y-%m-%d-%H-%M-%S.ipa&apos;,time.localtime(time.time())) os.system (&apos;xcrun -sdk iphoneos PackageApplication -v %s -o %s/%s&apos;%(app_path,targerIPA_parth,ipa_filename))#上传def upload_fir(): if os.path.exists(&apos;%s/%s&apos; % (targerIPA_parth,ipa_filename)): print(&apos;watting...&apos;) # 直接使用fir 有问题 这里使用了绝对地址 在终端通过 which fir 获得 ret = os.system(&apos;fir p %s/%s -T %s&apos; % (targerIPA_parth,ipa_filename,fir_api_token)) else: print(&apos;没有找到ipa文件&apos;)def _format_addr(s): name, addr = parseaddr(s) return formataddr((Header(name, &apos;utf-8&apos;).encode(), addr))# 发邮件def send_mail(): msg = MIMEText(&apos;xx iOS测试项目已经打包完毕，请前往 http://fir.im/xxxxx 下载测试！&apos;, &apos;plain&apos;, &apos;utf-8&apos;) msg[&apos;From&apos;] = _format_addr(&apos;自动打包系统 &lt;%s&gt;&apos; % from_addr) msg[&apos;To&apos;] = _format_addr(&apos;xx测试人员 &lt;%s&gt;&apos; % to_addr) msg[&apos;Subject&apos;] = Header(&apos;xx iOS客户端打包程序&apos;, &apos;utf-8&apos;).encode()# pop = poplib.POP3(&quot;pop3.mxhichina.com&quot;)# pop.set_debuglevel(1) #会打印出debug信息# pop.user(from_addr)# pop.pass_(password) server = smtplib.SMTP(smtp_server, 25) server.set_debuglevel(1) server.login(from_addr, password) server.sendmail(from_addr, [to_addr], msg.as_string()) server.quit()def main(): # 清理并创建build目录 clean_project_mkdir_build() # 编译coocaPods项目文件并 执行编译目录 build_project() # 打包ipa 并制定到桌面 build_ipa() # 上传fir # upload_fir() # 发邮件# send_mail() #暂时不用，需要配置企业邮箱的端口号和服务器# 执行main() 后话：附上之前写的文章，欢迎指正：荼菜的iOS笔记–Core Animation 核心动画 荼菜的iOS笔记–UIView的几个Block动画荼菜的iOS笔记–一些实用功能。荼菜的iOS笔记–UITableViewCell的各种操作（刷新、插入、删除、动画）荼菜的iOS笔记–一张图记住所有git命令行操作。荼菜的iOS笔记–一张图告诉你程序员需要知道的这些网站。荼菜的iOS笔记–图片裁剪黑魔法。荼菜的iOS笔记–我的编码规范参考。荼菜的iOS笔记–iOS基础优秀博客总结ToDoList荼菜的iOS笔记–Xcode Tips当然，我还写过诗。。。光。","tags":[]}]