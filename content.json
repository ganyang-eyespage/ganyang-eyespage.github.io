[{"title":"荼菜的iOS笔记--精解RunLoop笔记","date":"2017-03-07T05:38:39.000Z","path":"2017/03/07/荼菜的iOS笔记-精解RunLoop笔记/","text":"1. Run Loops in Cocoa: NSURLConnection–(底层)–&gt;AFNetworking dispatch_get_main_queue() CADisplaLink CATransition CAAnimation NSObject(NSDelayedPerforming) 、NSObject(NSTreadPerformAddition) … 2. RunLoop机制 NSRunLoop是CFRunLoop的封装，直接看CF(Core Foundation)这一层就好. RunLoop与线程和释放池之间的关系：苹果不允许直接创建RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain()和CGRunLoopGetCurrent()。这两个函数内部逻辑大概是下面这样：1234567891011121314151617181920212223242526272829303132333435363738/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;/// 访问 loopsDic 时的锁static CFSpinLock_t loopsLock; /// 获取一个 pthread 对应的 RunLoop。CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123; OSSpinLockLock(&amp;loopsLock); if (!loopsDic) &#123; // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。 loopsDic = CFDictionaryCreateMutable(); CFRunLoopRef mainLoop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop); &#125; /// 直接从 Dictionary 里获取。 CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread)); if (!loop) &#123; /// 取不到时，创建一个 loop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, thread, loop); /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。 _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop); &#125; OSSpinLockUnLock(&amp;loopsLock); return loop;&#125; CFRunLoopRef CFRunLoopGetMain() &#123; return _CFRunLoopGet(pthread_main_thread_np());&#125; CFRunLoopRef CFRunLoopGetCurrent() &#123; return _CFRunLoopGet(pthread_self());&#125; CFRunLoop与Thread的关系： CFRunLoop与线程是一一绑定的关系（或者理解为RunLoop寄生于线程），一个线程自能有唯一对应的runloop；但是这个根runloop里可以嵌套子runloops。从上面的代码中我们可以看到，线程和RunLoop保存在一个全局的Dictionary里（Dic={@“线程”：@“RunLoop”}）。线程刚创建时并没有RunLoop，如果你不主动获取，那它一直都不会有。RunLoop的创建是发生在第一次获取时，RunLoop的销毁是发生在线程结束时。你只能在一个线程的内部获取其RunLoop（主线程除外）。 CFRunLoop与释放池的关系： 自动释放池寄生于RunLoop。程序启动后，主线程注册了两个Observer监听runloop的进出与休眠。一个最高级Observer监听Entry状态；一个最低级Observer监听BeforeWaiting状态和Exit状态。 线程(创建)–&gt;runloop将进入–&gt;最高优先级OB创建释放池–&gt;runloop将睡–&gt;最低优先级OB销毁旧池创建新池–&gt;runloop将退出–&gt;最低优先级OB销毁新池–&gt;线程(销毁) 3. CFRunLoopRef的构造：12345678910111213141516struct __CFRunLoopMode &#123; CFStringRef _name; // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot; CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ...&#125;; struct __CFRunLoop &#123; CFMutableSetRef _commonModes; // Set CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt; CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set ...&#125;; 这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。 应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。 有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。 一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 4. CFRunLoopModelRef： 数据构造 （见上） 创建与添加 ：runloop自动创建对应的mode；mode只能添加不能删除 1CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);// 添加mode 类型 ： 123451. kCFRunLoopDefaultMode: 默认 mode，通常主线程在这个 Mode 下运行。2. UITrackingRunLoopMode: 追踪mode，保证Scrollview滑动顺畅不受其他 mode 影响。3. UIInitializationRunLoopMode: 启动程序后的过渡mode，启动完成后就不再使用。4: GSEventReceiveRunLoopMode: Graphic相关事件的mode，通常用不到。5: kCFRunLoopCommonModes: 占位mode，作为标记DefaultMode和CommonMode用。 modeItems ： 123456// 添加移除item的函数（参数：添加/移除哪个item到哪个runloop的哪个mode下）CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); 你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。 4.1 CFRunLoopSourceRef: 数据构造 1234// source0 (manual): order(优先级)，callout(回调函数)CFRunLoopSource &#123;order =..., &#123;callout =... &#125;&#125;// source1 (mach port)：order(优先级)，port:(端口), callout(回调函数)CFRunLoopSource &#123;order = ..., &#123;port = ..., callout =...&#125; • Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。• Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。 4.2 CFRunLoopTimerRef: CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 数据构造 12// Timer：interval:(闹钟间隔), tolerance:(延期时间容忍度)，callout(回调函数)CFRunLoopTimer &#123;firing =..., interval = ...,tolerance = ...,next fire date = ...,callout = ...&#125; 创建与生效 1234//NSTimer：// 创建一个定时器（需要手动加到runloop的mode中）+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo; // 默认已经添加到主线程的runLoop的DefaultMode中 + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo;// performSEL方法// 内部会创建一个Timer到当前线程的runloop中（如果当前线程没runloop则方法无效；performSelector:onThread: 方法放到指定线程runloop中）- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay 相关类型（GCD的timer与CADisplayLink)GCD的timer：dispatch_source_t 类型，可以精确的参数，不用以来runloop和mode，性能消耗更小。 1dispatch_source_set_timer(dispatch_source_t source, // 定时器对象dispatch_time_t start, // 定时器开始执行的时间uint64_t interval, // 定时器的间隔时间uint64_t leeway // 定时器的精度 ); CADisplayLink ：Timer的tolerance表示最大延期时间，如果因为阻塞错过了这个时间精度，这个时间点的回调也会跳过去，不会延后执行。CADisplayLink 是一个和屏幕刷新率一致的定时器，如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似，只是没有tolerance容忍时间），造成界面卡顿的感觉。 4.3 CFRunLoopObserverRef:监听runloop状态，接收回调信息（常见于自动释放池创建销毁） 数据构造 12// Observer：order(优先级)，ativity(监听状态)，callout(回调函数)CFRunLoopObserver &#123;order = ..., activities = ..., callout = ...&#125; 创建与添加 123456// 第一个参数用于分配该observer对象的内存空间// 第二个参数用以设置该observer监听什么状态// 第三个参数用于标识该observer是在第一次进入run loop时执行还是每次进入run loop处理时均执行// 第四个参数用于设置该observer的优先级,一般为0// 第五个参数用于设置该observer的回调函数// 第六个参数observer的运行状态 CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; // 执行代码&#125; 监听的状态 1typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 5. RunLoop 内部逻辑： 关键在两个判断点（是否睡觉，是否退出） 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// RunLoop的实现int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123; // 0.1 根据modeName找到对应mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false); // 0.2 如果mode里没有source/timer/observer, 直接返回。if (__CFRunLoopModeIsEmpty(currentMode)) return; // 1.1 通知 Observers: RunLoop 即将进入 loop。---（OB会创建释放池）__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry); // 1.2 内部函数，进入loop__CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;Boolean sourceHandledThisLoop = NO;int retVal = 0; do &#123; // 2.1 通知 Observers: RunLoop 即将触发 Timer 回调。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers); // 2.2 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources); // 执行被加入的block__CFRunLoopDoBlocks(runloop, currentMode); // 2.3 RunLoop 触发 Source0 (非port) 回调。sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle); // 执行被加入的block__CFRunLoopDoBlocks(runloop, currentMode); // 2.4 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。if (__Source0DidDispatchPortLastTime) &#123;Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg) if (hasMsg) goto handle_msg; &#125; // 3.1 如果没有待处理消息，通知 Observers: RunLoop 的线程即将进入休眠(sleep)。--- (OB会销毁释放池并建立新释放池)if (!sourceHandledThisLoop) &#123; __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting); &#125; // 3.2. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。// - 一个基于 port 的Source1 的事件。// - 一个 Timer 到时间了// - RunLoop 启动时设置的最大超时时间到了// - 被手动唤醒__CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123; mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg &#125; // 3.3. 被唤醒，通知 Observers: RunLoop 的线程刚刚被唤醒了。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); // 4.0 处理消息。handle_msg: // 4.1 如果消息是Timer类型，触发这个Timer的回调。if (msg_is_timer) &#123; __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time()) &#125; // 4.2 如果消息是dispatch到main_queue的block，执行block。else if (msg_is_dispatch) &#123; __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); &#125;// 4.3 如果消息是Source1类型，处理这个事件else &#123; CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandledThisLoop) &#123;mach_msg(reply, MACH_SEND_MSG, reply); &#125; &#125; // 执行加入到Loop的block__CFRunLoopDoBlocks(runloop, currentMode); // 5.1 如果处理事件完毕，启动Runloop时设置参数为一次性执行,设置while参数退出Runloopif (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; retVal = kCFRunLoopRunHandledSource; // 5.2 如果启动Runloop时设置的最大运转时间到期，设置while参数退出Runloop &#125; else if (timeout) &#123; retVal = kCFRunLoopRunTimedOut; // 5.3 如果启动Runloop被外部调用强制停止，设置while参数退出Runloop &#125; else if (__CFRunLoopIsStopped(runloop)) &#123; retVal = kCFRunLoopRunStopped; // 5.4 如果启动Runloop的modeItems为空，设置while参数退出Runloop &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;retVal = kCFRunLoopRunFinished; &#125;// 5.5 如果没超时，mode里没空，loop也没被停止，那继续loop，回到第2步循环。&#125; while (retVal == 0); &#125; // 6. 如果第6步判断后loop退出，通知 Observers: RunLoop 退出。--- (OB会销毁新释放池)__CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&#125;``` * **简化实现过程** 1- Entry：通知OB（创建pool）；2- 执行阶段：按顺序通知OB并执行timer，source0；若有source1执行source1；3- 休眠阶段：利用mach_msg判断进入休眠，通知OB（pool的销毁重建）；被消息唤醒通知OB；4- 执行阶段：按消息类型处理事件；5- 判断退出条件：如果符合退出条件（一次性执行，超时，强制停止，modeItem为空）则退出，否则回到第2阶段；6- Exit：通知OB（销毁pool）。1# 6. RunLoop 本质：mach port和mach_msg() Mach是XNU的内核，进程、线程和虚拟内存等对象通过端口发消息进行通信，Runloop通过mach_msg()函数发送消息，如果没有port 消息，内核会将线程置于等待状态 mach_msg_trap() 。如果有消息，判断消息类型处理事件，并通过modeItem的callback回调。123# 7. RunLoop如何处理事件（举例* **界面刷新** 当UI改变（ Frame变化、 UIView/CALayer 的继承结构变化等）时，或手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理。苹果注册了一个用来监听BeforeWaiting和Exit的Observer，在它的回调函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 1* **事件响应** 当一个硬件事件(触摸/锁屏/摇晃/加速等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收， 随后由mach port 转发给需要的App进程。苹果注册了一个 Source1 (基于 mach port 的) 来接收系统事件，通过回调函数触发Sourece0（所以UIEvent实际上是基于Source0的），调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。 1* **手势识别** 如果上一步的 _UIApplicationHandleEventQueue() 识别到是一个guesture手势，会调用Cancel方法将当前的touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，其回调函数为 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 12* **GCD任务** 当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调里执行这个 block。Runloop只处理主线程的block，dispatch 到其他线程仍然是由 libDispatch 处理的。 12* **网络请求** 关于网络请求的接口:最底层是CFSocket层，然后是CFNetwork将其封装，然后是NSURLConnection对CFNetwork进行面向对象的封装，NSURLSession 是 iOS7 中新增的接口，也用到NSURLConnection的loader线程。所以还是以NSURLConnection为例。当开始网络传输时，NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。 123456789![666982-9bf4831b87769d5a.png](http://upload-images.jianshu.io/upload_images/1438251-974107aba47b23f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)# 8.应用* **滑动与图片刷新**当tableview的cell上有需要从网络获取的图片的时候，滚动tableView，异步线程会去加载图片，加载完成后主线程就会设置cell的图片，但是会造成卡顿。可以让设置图片的任务在CFRunLoopDefaultMode下进行，当滚动tableView的时候，RunLoop是在 UITrackingRunLoopMode 下进行，不去设置图片，而是当停止的时候，再去设置图片。 (void)viewDidLoad {[super viewDidLoad];// 只在NSDefaultRunLoopMode下执行(刷新图片)[self.myImageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@””] afterDelay:ti inModes:@[NSDefaultRunLoopMode]];} 12* **常驻子线程，保持子线程一直处理事件**为了保证线程长期运转，可以在子线程中加入RunLoop，并且给Runloop设置item，防止Runloop自动退出。 (void)networkRequestThreadEntryPoint:(id)__unused object {@autoreleasepool {[[NSThread currentThread] setName:@”AFNetworking”];NSRunLoop *runLoop = [NSRunLoop currentRunLoop];[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];[runLoop run];}} (NSThread )networkRequestThread {static NSThread _networkRequestThread = nil;static dispatch_once_t oncePredicate;dispatch_once(&amp;oncePredicate, ^{_networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];[_networkRequestThread start]; });return _networkRequestThread;} (void)start {[self.lock lock];if ([self isCancelled]) {[self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];} else if ([self isReady]) {self.state = AFOperationExecutingState;[self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];}[self.lock unlock];} ```","tags":[]},{"title":"荼菜的iOS笔记--iOS自动打包","date":"2016-12-02T13:34:02.000Z","path":"2016/12/02/荼菜的iOS笔记-iOS自动打包/","text":"最近几天学Python，顺便写了个自动打包的脚本，给大家做个参考。注释和步骤代码里都写得有，使用时把工程路径换了就行。可以直接拷贝到你的.py文件里执行。当然你还可以来我的GitHub直接下载文件Python_Archiveipa 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import osimport sysimport timeimport hashlibfrom email import encodersfrom email.header import Headerfrom email.mime.text import MIMETextfrom email.utils import parseaddr, formataddrimport smtplib# 项目根目录project_path = &apos;/Users/yanggan/Desktop/jucai-ios-app&apos;# 编译成功后.app所在目录 其中&apos;/Users/yanggan/Desktop/jucai-ios-app&apos;为项目路径app_path = &apos;%s/build/Build/Products/Release-iphoneos/JuCaiShengHuo.app&apos; % (project_path)# 指定项目下编译目录build_path = &apos;build&apos;# 打包后ipa存储目录targerIPA_parth = &apos;/Users/yanggan/Desktop&apos;# 项目名称project_name = &apos;JuCaiShengHuo&apos;# ipafilenameipa_filename = &apos;JuCaiShengHuo.ipa&apos;# firm的api token 需要自己申请账号，申请地址-&gt; http://fir.im/appsfir_api_token = &apos;4a0d2512c33d0a10ca0e59dbd04b45b0&apos;# 需要自己配置邮件端口号，服务器和对方邮箱地址#from_addr = &quot;邮件地址&quot;#password = &quot;邮件密码&quot;#smtp_server = &quot;smtp.服务器&quot;#to_addr = &quot;对方邮件地址&quot;# 清理项目 创建build目录def clean_project_mkdir_build(): os.system(&apos;cd %s;xcodebuild clean&apos; % project_path) # clean 项目 os.system(&apos;cd %s;mkdir build&apos; % project_path)def build_project(): print(&apos;build release start&apos;) os.system (&apos;xcodebuild -list&apos;) os.system (&apos;cd %s;xcodebuild -workspace %s.xcworkspace -scheme %s -configuration release -derivedDataPath %s ONLY_ACTIVE_ARCH=NO || exit&apos; % (project_path,project_name,project_name,build_path))# CONFIGURATION_BUILD_DIR=./build/Release-iphoneos# 打包ipa 并且保存在桌面def build_ipa(): global ipa_filename# ipa_filename = time.strftime(&apos;xx_%Y-%m-%d-%H-%M-%S.ipa&apos;,time.localtime(time.time())) os.system (&apos;xcrun -sdk iphoneos PackageApplication -v %s -o %s/%s&apos;%(app_path,targerIPA_parth,ipa_filename))#上传def upload_fir(): if os.path.exists(&apos;%s/%s&apos; % (targerIPA_parth,ipa_filename)): print(&apos;watting...&apos;) # 直接使用fir 有问题 这里使用了绝对地址 在终端通过 which fir 获得 ret = os.system(&apos;fir p %s/%s -T %s&apos; % (targerIPA_parth,ipa_filename,fir_api_token)) else: print(&apos;没有找到ipa文件&apos;)def _format_addr(s): name, addr = parseaddr(s) return formataddr((Header(name, &apos;utf-8&apos;).encode(), addr))# 发邮件def send_mail(): msg = MIMEText(&apos;xx iOS测试项目已经打包完毕，请前往 http://fir.im/xxxxx 下载测试！&apos;, &apos;plain&apos;, &apos;utf-8&apos;) msg[&apos;From&apos;] = _format_addr(&apos;自动打包系统 &lt;%s&gt;&apos; % from_addr) msg[&apos;To&apos;] = _format_addr(&apos;xx测试人员 &lt;%s&gt;&apos; % to_addr) msg[&apos;Subject&apos;] = Header(&apos;xx iOS客户端打包程序&apos;, &apos;utf-8&apos;).encode()# pop = poplib.POP3(&quot;pop3.mxhichina.com&quot;)# pop.set_debuglevel(1) #会打印出debug信息# pop.user(from_addr)# pop.pass_(password) server = smtplib.SMTP(smtp_server, 25) server.set_debuglevel(1) server.login(from_addr, password) server.sendmail(from_addr, [to_addr], msg.as_string()) server.quit()def main(): # 清理并创建build目录 clean_project_mkdir_build() # 编译coocaPods项目文件并 执行编译目录 build_project() # 打包ipa 并制定到桌面 build_ipa() # 上传fir # upload_fir() # 发邮件# send_mail() #暂时不用，需要配置企业邮箱的端口号和服务器# 执行main() 后话：附上之前写的文章，欢迎指正：荼菜的iOS笔记–Core Animation 核心动画 荼菜的iOS笔记–UIView的几个Block动画荼菜的iOS笔记–一些实用功能。荼菜的iOS笔记–UITableViewCell的各种操作（刷新、插入、删除、动画）荼菜的iOS笔记–一张图记住所有git命令行操作。荼菜的iOS笔记–一张图告诉你程序员需要知道的这些网站。荼菜的iOS笔记–图片裁剪黑魔法。荼菜的iOS笔记–我的编码规范参考。荼菜的iOS笔记–iOS基础优秀博客总结ToDoList荼菜的iOS笔记–Xcode Tips当然，我还写过诗。。。光。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"荼菜的iOS笔记--我的编码规范参考.","date":"2016-12-02T08:38:22.000Z","path":"2016/12/02/荼菜的iOS笔记-我的编码规范参考/","text":"前言：下面是我的编码习惯。 12345678#一、常量相对字符串字面量或数字，我们更推荐适用常量。应使用static方式声明常量，而非使用#define的方式来定义宏。例如：static NSString * const NYTAboutViewControllerCompanyName = @&quot;The New York Times Company&quot;; static const CGFloat NYTImageThumbnailHeight = 50.0;不恰当://#define CompanyName @&quot;The New York Times Company&quot;//#define thumbnailHeight 2 1234567#二、枚举类型在使用enum的时候，推荐适用最新的fixed underlying type(WWDC 2012 session 405- Modern Objective-C)规范，因为它具备更强的类型检查和代码完成功能。如：typedef NS_ENUM(NSInteger, NYTAdRequestState) &#123;NYTAdRequestStateInactive,NYTAdRequestStateLoading&#125;; 123#三、布尔变量如果一个BOOL属性使用形容词来表达，属性将忽略’is’前缀，但会强调惯用名称。 例如：@property (assign, getter=isEditable) BOOL editable; 1234567891011#四、单例在创建单例对象的共享实例时，应使用线程安全模式。如：(instancetype)sharedInstance &#123;static id sharedInstance = nil;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;sharedInstance = [[self alloc] init];&#125;);return sharedInstance;&#125; 12345678910111213141516#五、Import在类的头文件中需要引用其他的类的时候，需要用@class这个关键字，这样能减少类与类之间的依赖。如:store.h:#import &lt;Foundation/Foundation.h&gt;#import &lt;CoreData/CoreData.h&gt;@class User;@interface Store : NSManagedObject@property (nonatomic, retain) User *user;@endStore.m:#import &quot;Store.h&quot;#import &quot;User.h&quot;@implementation Store//doSomething@end 1234567891011121314#六、CGRect函数当需要获取一个CGRect矩形的x,y,width,height属性时，应使用CGGeometry函数，而非直接访问结构体成员。如：CGRect frame = self.view.frame;CGFloat x = CGRectGetMinX(frame);CGFloat y = CGRectGetMinY(frame);CGFloat width = CGRectGetWidth(frame);CGFloat height = CGRectGetHeight(frame);不恰当：CGRect frame = self.view.frame;CGFloat x = frame.origin.x;CGFloat y = frame.origin.y;CGFloat width = frame.size.width;CGFloat height = frame.size.height; 后话：附上之前写的文章，欢迎指正：荼菜的iOS笔记–Core Animation 核心动画 荼菜的iOS笔记–UIView的几个Block动画荼菜的iOS笔记–一些实用功能。荼菜的iOS笔记–UITableViewCell的各种操作（刷新、插入、删除、动画）荼菜的iOS笔记–一张图记住所有git命令行操作。荼菜的iOS笔记–一张图告诉你程序员需要知道的这些网站。荼菜的iOS笔记–图片裁剪黑魔法。荼菜的iOS笔记–iOS自动打包脚本（Python） 荼菜的iOS笔记–iOS基础优秀博客总结ToDoList荼菜的iOS笔记–Xcode Tips当然，我还写过诗。。。光。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"荼菜的iOS笔记--UIView的几个Block动画","date":"2016-09-08T11:34:19.000Z","path":"2016/09/08/荼菜的iOS笔记-UIView的几个Block动画/","text":"前言：我的第一篇文章荼菜的iOS笔记–Core Animation 核心动画算是比较详细讲了核心动画的用法，但是如你上篇看到的，有时我们只是想实现一些很小的动画，这时再用coreAnimation就会觉得麻烦，不用慌，苹果工程师爸爸们已经为我们给UIView封装好了一些coreAnimationBlock，足以满足平时的动画需求。 动画Block1 12345678910/* 参数1: Duration: 动画持续时间参数2: delay: 延迟时间参数3: options: 枚举值 动画的效果类型*/[UIView animateWithDuration:2 delay:1 options:UIViewAnimationOptionCurveEaseInOut animations:^&#123;ws.MyLabel.frame = CGRectMake(100, 100, 100, 100);&#125; completion:^(BOOL finished) &#123;NSLog(@&quot;结束了%d&quot;, finished); &#125;]; 动画Block2-(模拟弹簧弹跳的效果) 1234567891011/*Spring: 模拟弹簧弹跳的效果参数: Damping:阻尼 0-1 阻尼越小动画越明显参数: initialSpringVelocity : 动画初始变化速度参数: options 转变的风格 枚举值*/[UIView animateWithDuration:10 delay:0 usingSpringWithDamping:0.1 initialSpringVelocity:15 options:(UIViewAnimationOptionCurveEaseInOut) animations:^&#123;ws.MyLabel.center = CGPointMake(self.view.center.x, 100);&#125; completion:^(BOOL finished) &#123;NSLog(@&quot;弹簧效果结束&quot;);&#125;]; 动画Block3-(关键帧动画)也就是里面有好几个动画进行转变 1234567891011121314151617181920212223/*Duration:持续时间delay: 延迟时间options: 枚举值 动画的风格*/[UIView animateKeyframesWithDuration:3 delay:0 options:(UIViewKeyframeAnimationOptionRepeat) animations:^&#123;/*参数1: RelativeStartTime: 相对的开始时间参数2: relativeDuration:相对持续时间*/[UIView addKeyframeWithRelativeStartTime:0.0 relativeDuration:0.5 animations:^&#123;ws.MyLabel.center = self.view.center;&#125;];[UIView addKeyframeWithRelativeStartTime:0.5 relativeDuration:0.3 animations:^&#123;ws.MyLabel.frame = CGRectMake(100, 100, 100, 100);&#125;];[UIView addKeyframeWithRelativeStartTime:0.8 relativeDuration:0.3 animations:^&#123;ws.MyLabel.frame = CGRectMake(100, 400, 100, 100);&#125;]; &#125; completion:^(BOOL finished) &#123;NSLog(@&quot;开始了吗？已经结束了。。&quot;);&#125;]; Masonry动画更新约束1.有时不适用12345678910111213[ws.allWarpView mas_updateConstraints:^(MASConstraintMaker *make) &#123;make.left.equalTo(ws.view.mas_left);make.right.equalTo(ws.view.mas_right);make.top.equalTo(ws.view.mas_top);make.bottom.equalTo(ws.view.mas_bottom);&#125;];// 告诉self.view约束需要更新[self.view setNeedsUpdateConstraints];// 调用此方法告诉self.view检测是否需要更新约束，若需要则更新，下面添加动画效果才起作用[self.view updateConstraintsIfNeeded];[UIView animateWithDuration:0.3 animations:^&#123;[self.view layoutIfNeeded];&#125;]; 2.解决12345678 [self layoutIfNeeded];//如果其约束还没有生成的时候需要动画的话，就请先强制刷新后才写动画，否则所有没生成的约束会直接跑动画 JCWeakSelf [UIView animateWithDuration:0.3 animations:^&#123; [_keywordTextField mas_updateConstraints:^(MASConstraintMaker *make) &#123; make.width.mas_equalTo(@(255*RealScaleFactor)); &#125;]; [ws layoutIfNeeded];//强制绘制 &#125;]; 后话：附上之前写的文章，欢迎指正：荼菜的iOS笔记–Core Animation 核心动画 荼菜的iOS笔记–一些实用功能。荼菜的iOS笔记–UITableViewCell的各种操作（刷新、插入、删除、动画）荼菜的iOS笔记–一张图记住所有git命令行操作。荼菜的iOS笔记–一张图告诉你程序员需要知道的这些网站。荼菜的iOS笔记–图片裁剪黑魔法。荼菜的iOS笔记–iOS自动打包脚本（Python） 荼菜的iOS笔记–我的编码规范参考。荼菜的iOS笔记–iOS基础优秀博客总结ToDoList荼菜的iOS笔记–Xcode Tips当然，我还写过诗。。。光。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"荼菜的iOS笔记--Xcode Tips","date":"2016-04-09T02:14:23.000Z","path":"2016/04/09/荼菜的iOS笔记-Xcode-Tips/","text":"前言：孙源大神总结了几个 Xcode 小技巧，为方便自己查看遂自己拷贝一份 #一、快速定位方法调用者 #二、继续编译有Error的工程 #三、给@prorerty设置断点 后话：附上之前写的文章，欢迎指正：荼菜的iOS笔记–Core Animation 核心动画 荼菜的iOS笔记–UIView的几个Block动画荼菜的iOS笔记–一些实用功能。荼菜的iOS笔记–UITableViewCell的各种操作（刷新、插入、删除、动画）荼菜的iOS笔记–一张图记住所有git命令行操作。荼菜的iOS笔记–一张图告诉你程序员需要知道的这些网站。荼菜的iOS笔记–图片裁剪黑魔法。荼菜的iOS笔记–iOS自动打包脚本（Python） 荼菜的iOS笔记–我的编码规范参考。荼菜的iOS笔记–iOS基础优秀博客总结ToDoList当然，我还写过诗。。。光。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"荼菜的iOS笔记--UITableViewCell的各种操作（刷新、插入、删除、动画）","date":"2016-04-02T03:56:06.000Z","path":"2016/04/02/荼菜的iOS笔记-UITableViewCell的各种操作（刷新、插入、删除、动画）/","text":"前言：最近在做一个聊天的对话机器人应用，主界面就是一个tableView，所以难免用到了对cell的各种操作。下边代码全部为从工程中拷贝出来的，以备自己下次使用，由于是公司的工程，故不能贴出Demo，但如有有疑问还可以问我，必定有问必答。 ##一、刷新数据源123456//刷新整个Section- (void)reloadDataBySection&#123;NSIndexSet* indexSet = [NSIndexSet indexSetWithIndex:0];[self.tableView reloadSections:indexSet withRowAnimation:UITableViewRowAnimationTop];&#125; 123456//通过刷新某个Section的每一个Row来刷新Section - (void)reloadDataBySection&#123;NSIndexSet* indexSet = [NSIndexSet indexSetWithIndex:0];[self.tableView reloadSections:indexSet withRowAnimation:UITableViewRowAnimationTop];&#125; 12345//刷新单行- (void)reloadSingleRow&#123;[self.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];&#125; ##二、插入数据源在调用insertRowsAtIndexPaths和deleteRowsAtIndexPaths的时候一定要先改变数据源，在调用上述函数，不然会产生crash。 12@property (nonatomic,strong) NSMutableArray *indexPathsArray;_indexPathsArray = [NSMutableArray array]; 1234567891011121314151617#pragma mark -- 聊天界面数据刷新//删除最后一行waiting气泡-(void)deleteData&#123;[_datas removeLastObject];[_indexPathsArray addObject:[NSIndexPath indexPathForItem:_datas.count inSection:0]];[self.tableView deleteRowsAtIndexPaths:_indexPathsArray withRowAnimation:UITableViewRowAnimationFade];[_indexPathsArray removeAllObjects];&#125;//新增一条消息气泡-(void)insertData&#123;[ws.datas addObject:model];[_indexPathsArray addObject:[NSIndexPath indexPathForItem:_datas.count-1 inSection:0]];[self.tableView insertRowsAtIndexPaths:_indexPathsArray withRowAnimation:UITableViewRowAnimationLeft];[_indexPathsArray removeAllObjects];&#125; 12345//插入一个Section-(void)insertData&#123;NSInteger datasCount = _datas.count&gt;1?_datas.count-1:0;[self.tableView insertSections:[NSIndexSet indexSetWithIndex:datasCount] withRowAnimation:UITableViewRowAnimationTop];&#125; ##三、获取cell所在frame 12345678910111213//应用场景：点击Cell后要执行动画，动画需要从当前cell的frame开始变化的场景- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123;CGRect cellFrameInTableView = [tableView rectForRowAtIndexPath:indexPath];CGRect cellFrameInSuperview = [tableView convertRect:cellFrameInTableView toView:[tableView superview]];DetailViewController* detailViewController = [[DetailViewController alloc] initWithNibName:@&quot;DetailViewController&quot; bundle:nil];NSMutableDictionary* dict = [self.arrayForPlaces objectAtIndex:indexPath.row];detailViewController.dictForData = dict;detailViewController.yOrigin = cellFrameInSuperview.origin.y;[self.navigationController pushViewController:detailViewController animated:NO];[detailViewController release];[tableView deselectRowAtIndexPath:indexPath animated:YES];&#125; 123456//同理，下边为获取**collectionViewCell**相对屏幕和相对collectionView的frameCGRect cellFrame = [[collectionView cellForItemAtIndexPath:indexPath] frame];CGRect cellFrameInSuperView = [collectionView convertRect:cellFrame toView:collectionView];CGRect cellFrameInScreen = [collectionView convertRect:cellFrame toView:self];NSLog(@&quot;frameInSuperView --%f &quot;,cellFrameInSuperView.origin.x);NSLog(@&quot;cellReal --%f &quot;,cellFrameInScreen.origin.x); ##四、cell的一些动画 cell进入时动画，依次往上拱 12345678910111213141516171819-(void)startTableViewAnimation&#123;[self.tableView reloadData];NSArray *visibleCells=self.tableView.visibleCells;CGFloat tableHeight=self.tableView.bounds.size.height;for (UITableViewCell *cell in visibleCells) &#123;cell.transform = CGAffineTransformMakeTranslation(0, tableHeight);&#125;NSInteger index=0;for (UITableViewCell *cell in visibleCells) &#123;cell.transform = CGAffineTransformMakeTranslation(0, tableHeight);[UIView animateWithDuration:1.0 delay:0.01*index usingSpringWithDamping:0.8 initialSpringVelocity:0 options:UIViewAnimationOptionTransitionNone animations:^&#123;cell.transform = CGAffineTransformMakeTranslation(0, 0);&#125; completion:nil];index += 1;&#125;&#125; cell进入时动画，cell放大 12345678910-(void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath&#123;//设置Cell的动画效果为3D效果//设置x和y的初始值为0.1；cell.layer.transform = CATransform3DMakeScale(0.1, 0.1, 1);//x和y的最终值为1[UIView animateWithDuration:1 animations:^&#123;cell.layer.transform = CATransform3DMakeScale(1, 1, 1);&#125;];&#125; cell出现时，由斜变正 12345678910111213141516- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath &#123;// 从锚点位置出发，逆时针绕 Y 和 Z 坐标轴旋转90度CATransform3D transform3D = CATransform3DMakeRotation(M_PI_2, 0.0, 1.0, 1.0);// 定义 cell 的初始状态cell.alpha = 0.0;cell.layer.transform = transform3D;cell.layer.anchorPoint = CGPointMake(0.0, 0.5); // 设置锚点位置；默认为中心点(0.5, 0.5)// 定义 cell 的最终状态，执行动画效果[UIView animateWithDuration:0.5 animations:^&#123;cell.alpha = 1.0;cell.layer.transform = CATransform3DIdentity;CGRect rect = cell.frame;rect.origin.x = 0.0;cell.frame = rect;&#125;];&#125; cell删除动画 1234567[_tableViews deleteRowsAtIndexPaths:@[cell.indexPath] withRowAnimation:UITableViewRowAnimationLeft];[UIView animateWithDuration:0.3 animations:^&#123;cell.contentView.center = CGPoint(-width / 2, height / 2);&#125; completion:^(BOOL finished) &#123;[self.tableView deleteRowsAtIndexPaths:xxx withRowAnimation:UITableViewRowAnimationTop];&#125;]; cell依次插入动画 123456789101112131415161718192021222324252627282930313233343536@property(nonatomic,strong)NSMutableArray *indesPaths;@property (nonatomic,assign)int DatNum;@property(nonatomic,strong) NSTimer * timer;- (void)viewDidLoad &#123;[super viewDidLoad];[self configInit];[self loadData];[self startTableViewAnimation];self.DatNum = -1;NSMutableArray *indexPaths = @[].mutableCopy;self.indesPaths = indexPaths;self.timer = [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(charusell) userInfo:nil repeats:YES];&#125;-(void)charusell&#123;self.DatNum = self.DatNum +1;if (self.DatNum &lt; self.allDatas.count) &#123;[self.indesPaths addObject:[NSIndexPath indexPathForItem:self.DatNum inSection:0]];[self.tableView insertRowsAtIndexPaths:self.indesPaths withRowAnimation:UITableViewRowAnimationTop];[self.indesPaths removeAllObjects];&#125;else&#123;[self.timer invalidate];//记得当不用这个定时器的时候要销毁.self.timer = nil;&#125;&#125;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;// return _allDatas.count;return self.DatNum+1;&#125; 后话：附上之前写的文章，欢迎指正：荼菜的iOS笔记–Core Animation 核心动画 荼菜的iOS笔记–UIView的几个Block动画荼菜的iOS笔记–一些实用功能。荼菜的iOS笔记–一张图记住所有git命令行操作。荼菜的iOS笔记–一张图告诉你程序员需要知道的这些网站。荼菜的iOS笔记–图片裁剪黑魔法。荼菜的iOS笔记–iOS自动打包脚本（Python） 荼菜的iOS笔记–我的编码规范参考。荼菜的iOS笔记–iOS基础优秀博客总结ToDoList荼菜的iOS笔记–Xcode Tips当然，我还写过诗。。。光。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"荼菜的iOS笔记--iOS基础优秀博客总结ToDoList","date":"2016-03-28T11:41:46.000Z","path":"2016/03/28/荼菜的iOS笔记-iOS基础优秀博客总结ToDoList/","text":"前言：最近在总结iOS比较底层的东西，于是翻遍了各个大牛的博客，看到AidenRao总结的文章，挨个点进去看了很不错，于是又补充了些我觉得不错的文章，给自己做个备份。 #类和对象 iOS程序main函数之前发生了什么谈ObjC对象的两段构造模式从NSObject的初始化了解isa (1)深入解析ObjC中方法的结构(2)What is a meta-class in Objective-C?对象是如何初始化的深入理解Objective-C：Category #RunLoop ：YY大神(深入理解RunLoop)视频：孙源(百度)(线下分享RunLoop)RunLoop总结：RunLoop基础知识RunLoop 总结：RunLoop的应用场景（一）保证线程长久存活RunLoop 总结：RunLoop的应用场景（二）让Timer正常运转RunLoop总结：RunLoop的应用场景（三）滚动视图流畅性优化RunLoop总结：RunLoop的应用场景（四）App卡顿监测RunLoop总结：RunLoop的应用场景（五）阻止App崩溃一次 #RuntimeiOS-runtimeiOS-runtime理解iOS开发之Runtime常用示例总结深入理解Objective-C：方法缓存译:理解 Objective-C RuntimeObjective-C Runtime 1小时入门教程Method Swizzling 和 AOP 实践刨根问底：对于 self = [super init] 的思考 在objc中的一个重要的特点就是对象化。我们所用的 NSObject 这个类其实也是一个对象。如果我们初始化 NSObject *p = [[NSObject alloc] init]; ，那么 p 这个对象中在runtime时会当作一个结构体isa_t对象来处理。而其中的 isa 指针（由objc_object继承而来）会指向自身的类对象。也就是说，这里的 p.isa 是指向 NSObject （这种写法不太严格，但是可以这么描述）。同此，文中的 block 也为了模仿 对象 的结构，制作了一个isa属性。对于isa的具体细节我没有写过相关文章，但是强烈推荐学习这篇博文 runtime可以做什么？ 多继承 交换两个方法法的实现 关联对象 #GCDGCD 深入理解：第一部分GCD 深入理解：第二部分 #多线程 与 锁Objective-C中不同方式实现锁(一)Objective-C中不同方式实现锁(二)iOS中的锁iOS开发－多线程开发之线程安全篇iOS多线程-各种线程锁的简单介绍关于 @synchronized，这儿比你想知道的还要多iOS中保证线程安全的几种方式与性能对比 #并发编程Cocoa 并发编程iOS 多线程编程 —— GCD 与 NSOperation 总结 #MRC 和 ARCObjective-C 中的内存分配 #事件处理Cocoa Touch事件处理流程–响应者链iOS中的事件处理、响应者链条以及第一响应者在 Target-Action 中使用响应链 #设计模式设计模式 #动画荼菜的iOS笔记–Core Animation 核心动画 #流畅： 离屏渲染绘制像素到屏幕上 #SwiftSwift教程 #反编译(逆向)：工具 FLEXLoader #python： step 1： 两本书：《A Byte of Python》 《Learning Python》《Python核心编程 宋吉广 译》 step 2： 视频：Python 入门（imooc) step 3： 博客：菜鸟学python) #Unity3D体验第一个游戏雏形 #AFNetWorking #ResumeSampleResumeSample《招聘一个靠谱的 iOS》— 参考答案 #源码解析源码解析-Draveness #阿里巴巴hit-alibaba.github.io #拓展iOS 中armv7,armv7s,arm64,i386,x86_64 都是什么iOS开发～制作同时支持armv7,armv7s,arm64,i386,x86_64的静态库.aclang -rewrite-objc MyClass.m 执行上面的命令，将这一句重写为C代码 后话：附上之前写的文章，欢迎指正：荼菜的iOS笔记–Core Animation 核心动画 荼菜的iOS笔记–UIView的几个Block动画荼菜的iOS笔记–一些实用功能。荼菜的iOS笔记–UITableViewCell的各种操作（刷新、插入、删除、动画）荼菜的iOS笔记–一张图记住所有git命令行操作。荼菜的iOS笔记–一张图告诉你程序员需要知道的这些网站。荼菜的iOS笔记–图片裁剪黑魔法。荼菜的iOS笔记–iOS自动打包脚本（Python） 荼菜的iOS笔记–我的编码规范参考。荼菜的iOS笔记–Xcode Tips当然，我还写过诗。。。光。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"荼菜的iOS笔记--Core Animation 核心动画","date":"2016-03-02T08:55:36.000Z","path":"2016/03/02/荼菜的iOS笔记-Core-Animation-核心动画/","text":"前言：前些天学习核心动画时参考了一些别人的经验贴，之前是保存在自己的为知笔记里里的，只记录了一些适合自己的片段，因此有些出处来自于前人大神，但当时链接当时并未记录，望谅解。 #概念# Core Animation可以用在 Mac OS X 和 iOS平台. Core Animation的动画执行过程是在后台操作的.不会阻塞主线程. 要注意的是, Core Animation是直接作用在CALayer上的.并非UIView。 使用步骤：1、创建一个CAAnimation对象2、设置一些动画的相关属性3、给CALayer添加动画（addAnimation:forKey: 方法）4、停止CALayer动画（removeAnimationForKey: 方法）注意：1. 当你将animation加入layer层以后，你就无法再更改动画效果了。2.注意: 如果当动画正在执行的时候, 将程序退出到后台, 那么当程序再次进入前台的时候就不执行了。原因: 因为再次进入前台后动画已经被删除了。解决: anim.removedOnCompletion = NO; 一 、CAAnimationCAAnimation类是所有动画对象的父类，负责控制动画的持续时间和速度等，是个抽象类，不能直接使用，应该使用它具体的子类,CAAnimation的继承结构如下图： ##属性： duration：动画的持续时间，默认为0.25秒 repeatCount：动画的重复次数 repeatDuration：动画的重复时间 removedOnCompletion：默认为YES，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为NO，不过还要设置fillMode属性为kCAFillModeForwards fillMode：决定当前对象在非active时间段的行为.比如动画开始之前,动画结束之后 beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间 timingFunction：速度控制函数，控制动画运行的节奏 123456枚举参数：（1）kCAMediaTimingFunctionLinear 时间曲线函数，匀速（2）kCAMediaTimingFunctionEaseIn 时间曲线函数，由慢到特别快（3）kCAMediaTimingFunctionEaseOut 时间曲线函数，由快到慢（4）kCAMediaTimingFunctionEaseInEaseOut 时间曲线函数，由慢到快（5）kCAMediaTimingFunctionDefault 系统默认 delegate：动画代理，一般设置隐式代理，该代理是NSObject的分类，不需要遵守协议anim.delegate = self;（1）- (void)animationDidStart:(CAAnimation )anim;核心动画开始时执行（2）- (void)animationDidStop:(CAAnimation )anim finished:(BOOL)flag;核心动画执行结束后调用 二、 CAPropertyAnimation是CAAnimation的子类，也是个抽象类，要想创建动画对象，应该使用它的两个子类：CABasicAnimation和CAKeyframeAnimation 属性：@property(nullable, copy) NSString keyPath;类方法：+ (instancetype)animationWithKeyPath:(nullableNSString )path; keyPath参数：通过指定CALayer的一个属性名做为keyPath里的参数(NSString类型)，并且对CALayer的这个属性的值进行修改，达到相应的动画效果。比如，指定@”position”为keyPath，就修改CALayer的position属性的值，以达到平移的动画效果。 例子：CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@”position.y”]; 三、 CABasicAnimation（基本动画） 属性： fromValue : keyPath相应属性的初始值 toValue : keyPath相应属性的结束值，到某个固定的值（类似transform的make含义）注意：随着动画的进行,在长度为duration的持续时间内,keyPath相应属性的值从fromValue渐渐地变为toValue.如果fillMode = kCAFillModeForwards和removedOnComletion = NO;那么在动画执行完毕后,图层会保持显示动画执行后的状态,但实质上,图层的属性值还是动画执行前的初始值,并没有真正被改变.比如: CALayer的postion初始值为(0,0),CABasicAnimation的fromValue为(10,10),toValue为 (100,100),虽然动画执行完毕后图层保持在(100,100) 这个位置,实质上图层的position还是为(0,0); byValue：不断进行累加的数值（类似transform非make方法的含义）CABasicAnimation animation = [CABasicAnimation animationWithKeyPath:@”transform.rotation.z”];animation.byValue = @(M_PI 2); 四、 CAKeyframeAnimation（关键帧动画）和CABasicAnimation的区别：CABasicAnimation只能从一个数值(fromValue)变到另一个数值(toValue)，而CAKeyframeAnimation会使用一个NSArray（values）保存这些数值，实现多个点间的动画效果，CABasicAnimation可看做是最多只有2个关键帧的CAKeyframeAnimation 属性： 1.values:NSArray对象，里面的元素称为”关键帧”（NSValue类型），动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧（ NSValue）//设置动画属性NSValue p1 = [NSValue valueWithCGPoint:CGPointMake(50, 150)];NSValue p2 = [NSValue valueWithCGPoint:CGPointMake(250, 150)];NSValue p3 = [NSValue valueWithCGPoint:CGPointMake(50, 550)];NSValue p4 = [NSValue valueWithCGPoint:CGPointMake(250, 550)];animKey.values = @[p1, p2, p3, p4]; 2.path:可以设置一个CGPathRef\\CGMutablePathRef,让层跟着路径移动，path只对CALayer的anchorPoint(锚点)和position起作用，如果设置了path，那么values将被忽略。UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 100, 250, 100)];animKey.path = path.CGPath; 3.keyTimes：（keyTimes属性指定的是当前状态节点到初始状态节点的时间占动画总时长的比例。若果不设置keyTimes则匀速播放）可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧，当keyTimes没有设置的时候,各个关键帧的时间是平分的 4.rotationMode：旋转模式（1）如果为nil或不设置效果为 （2）设置为kCAAnimationRotateAuto 或 kCAAnimationRotateAutoReverse 会随着旋转的角度做 ”自转“ 五、 CAAnimationGroup（组动画）可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行属性：animations：动画组，用来保存一组动画对象的NSArray，默认情况下，一组动画对象是同时运行的，也可以通过设置动画对象的beginTime属性来更改动画的开始时间。 栗子🌰🔽 12345678910111213141516171819202122232425262728293031323334353637- (void)viewDidLoad &#123; [super viewDidLoad]; self.button.frame = CGRectMake(150, 100, 50, 50);&#125;-(UIButton *)button&#123; if (_button == nil) &#123; UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; button.backgroundColor=[UIColor redColor]; button.tag=0; [button addTarget:self action:@selector(buttonClicked:) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:button]; _button=button; &#125; return _button;&#125;//点击事件-(void)buttonClicked:(UIButton *)button&#123; CAKeyframeAnimation * animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;]; animation.values = @[[NSValue valueWithCGPoint:CGPointMake(0, 0)],[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(0, 200)]]; animation.duration = 2; animation.removedOnCompletion = NO; animation.fillMode = kCAFillModeForwards; animation.keyTimes = @[@0,@0.25,@0.5,@0.75,@1]; animation.path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(100, 100, 100, 100)].CGPath; CABasicAnimation * animation2 = [CABasicAnimation animationWithKeyPath:@&quot;cornerRadius&quot;]; animation2.toValue = @50; animation2.duration = 2; animation2.fillMode = kCAFillModeForwards; animation2.removedOnCompletion = NO; CAAnimationGroup * group = [CAAnimationGroup animation]; group.duration = 2; group.fillMode = kCAFillModeForwards; group.removedOnCompletion = NO; group.animations = @[animation,animation2]; [button.layer addAnimation:group forKey:@&quot;group&quot;];&#125; 六、 CATransition（转场动画）用于做转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。iOS比Mac OS X的转场动画效果少一点。UINavigationController就是通过CATransition实现了将控制器的视图推入屏幕的动画效果属性： 1.type：设置动画过渡的类型 2.subtype：设置动画过渡方向枚举:kCATransitionFromRightkCATransitionFromLeftkCATransitionFromTopkCATransitionFromBottom 3.startProgress：动画起点(在整体动画的百分比) 4.endProgress：动画终点(在整体动画的百分比) 场景：所以我目前测出来的能用的情况有，imageView切换图片，控制器的push或modal，UIView对象调用exchangeSubviewAtIndex：WithIndex：方法的时候可以出发转场动画，其他我真是没有测出来，有大神知道还望告知=。=十分感谢。 12345678910-(void)buttonClicked:(UIButton *)button&#123; CATransition *animation = [CATransition animation]; animation.duration = 5; animation.fillMode = kCAFillModeForwards; animation.type = @&quot;rippleEffect&quot;; animation.subtype = kCATransitionFromTop; [self.img.layer addAnimation:animation forKey:@&quot;ripple&quot;]; self.img.image = [UIImage imageNamed:@&quot;ic_empty_theater&quot;];&#125; 后话：附上之前写的文章，欢迎指正：荼菜的iOS笔记–UIView的几个Block动画荼菜的iOS笔记–一些实用功能。荼菜的iOS笔记–UITableViewCell的各种操作（刷新、插入、删除、动画）荼菜的iOS笔记–一张图记住所有git命令行操作。荼菜的iOS笔记–一张图告诉你程序员需要知道的这些网站。荼菜的iOS笔记–图片裁剪黑魔法。荼菜的iOS笔记–iOS自动打包脚本（Python） 荼菜的iOS笔记–我的编码规范参考。荼菜的iOS笔记–iOS基础优秀博客总结ToDoList荼菜的iOS笔记–Xcode Tips当然，我还写过诗。。。光。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"荼菜的iOS笔记--一些实用功能。","date":"2015-12-25T08:52:56.000Z","path":"2015/12/25/荼菜的iOS笔记-一些实用功能。/","text":"前言：开发过程中遇到许多不太熟练的知识点，这些都是借鉴别人又被我应用的一些东西，之前是遇到一点就记录到笔记里，时间久了知识点就有点散，正好整理到一起，欢迎收藏，以后还会陆续增加知识点。 1.不常用的属性1234567891011121314151617181920//取消自动布局self.automaticallyAdjustsScrollViewInsets = NO;//解决tabbar挡住最后一行问题self.edgesForExtendedLayout = UIRectEdgeNone;//隐藏cell线 self.tableView.separatorStyle = UITableViewCellSeparateStyleNone;//push到下个页面需要隐藏tabBar时svc.hidesBottomBarWhenPushed=YES;//多余cell空白self.tableView.tableFooterView = [[UIView alloc]init];//不超过屏幕也能滑self.ShowCollection.alwaysBounceVertical = YES;//选中cell 无背景色cell.selectionStyle = UITableViewCellSelectionStyleNone;//推时隐藏tabbarself.hidesBottomBarWhenPushed = YES;//button文字靠右[_button setContentHorizontalAlignment:UIControlContentHorizontalAlignmentRight];//button文字靠左[_button setContentHorizontalAlignment:UIControlContentHorizontalAlignmentLeft]; 2.解决时差问题1234567891011121314151617181920212223242526272829303132333435 //解决时差问题 NSDate * date = sender.date; NSTimeZone *zone = [NSTimeZone systemTimeZone]; NSInteger interval = [zone secondsFromGMTForDate: date]; NSDate *localeDate = [date dateByAddingTimeInterval: interval]; //时差转化 NSDate *datenow = [NSDate date];//输出结果:2014-12-12 02:23:25 +0000晚八个小时 NSTimeZone *zone = [NSTimeZone systemTimeZone]; NSInteger interval = [zone secondsFromGMTForDate:datenow]; NSDate *localeDate = [datenow dateByAddingTimeInterval: interval];//2014-12-12 10:23:25 +0000 NSLog(@&quot;%@&quot;, localeDate); //将秒数转化为日期格式 NSDate *confromTimesp = [NSDatedateWithTimeIntervalSince1970:1363948516]; NSLog(@&quot;1363948516 = %@&quot;,confromTimesp);//2013-03-22 10:35:16 +0000//将秒数转化为特定格式的日期格式NSString *str=@&quot;1368082020&quot;;//时间戳 NSTimeInterval time=[str doubleValue]+28800;//因为时差问题要加8小时 == 28800 sec NSDate *detaildate=[NSDate dateWithTimeIntervalSince1970:time]; NSLog(@&quot;date:%@&quot;,[detaildate description]); //实例化一个NSDateFormatter对象 NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; //设定时间格式,这里可以设置成自己需要的格式 [dateFormatter setDateFormat:@&quot;yyyy-MM-dd&quot;]; NSString *currentDateStr = [dateFormatter stringFromDate: detaildate];//最终版本 NSString * startStr = [NSStringstringWithFormat:@&quot;%@&quot;,dic[@&quot;startdate&quot;]]; NSTimeInterval startTime = [startStr doubleValue] / 1000 + 28800; NSDate * startLocalDate = [NSDatedateWithTimeIntervalSince1970:startTime]; NSDateFormatter * startFormatter = [[NSDateFormatter alloc]init]; [startFormatter setDateFormat:@&quot;yyyy.MM.dd&quot;]; NSString * startDate = [startFormatter stringFromDate:startLocalDate]; 3.页面切换水波纹动画12345678DetailViewController * dvc = [[DetailViewControlleralloc]initWithSid:self.dataArray[indexPath.row] [@&quot;secid&quot;]WithCollectorsCount:[self.dataArray[indexPath.row][@&quot;collectcnt&quot;]intValue]]; dvc.hidesBottomBarWhenPushed = YES; CATransition*transition=[CATransition animation]; transition.duration=1.0f; transition.type=@&quot;rippleEffect&quot;; transition.subtype=@&quot;fromTop&quot;; [self.navigationController.view.layer addAnimation:transitionforKey:nil]; [self.navigationController pushViewController:dvc animated:YES]; 4.去掉导航条和tabBar的边框1234567- (void)viewWillAppear:(BOOL)animated &#123; [self.navigationController.navigationBar setBackgroundImage:[TDUtils createImageWithColor:[UIColor clearColor]] forBarMetrics:UIBarMetricsDefault]; [self.navigationController.navigationBar setBackIndicatorTransitionMaskImage:[TDUtils createImageWithColor:[UIColor clearColor]]]; [self.navigationController.navigationBar setShadowImage:[TDUtils createImageWithColor:[UIColor clearColor]]]; [self.tabBarController.tabBar setBackgroundImage:[TDUtils createImageWithColor:[UIColor clearColor]]]; [self.tabBarController.tabBar setShadowImage:[TDUtils createImageWithColor:[UIColor clearColor]]];&#125; 5.导航条多按钮12NSArray *buttonArray = [[NSArray alloc]initWithObjects:cleanButton,saveButton, nil];self.navigationItem.rightBarButtonItems = buttonArray; 6.真机测试时出现的问题1234567No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=armv7, VA运行报错出现的原因：armv7s是应用在iPhone 5 A6 的架构上的解决的方式：1，在Project target里“Architectures”设置为“Standard （armv7,armv7s）”2，修改在Project target里“Build Settings”的“Valid Architectures”添加“i386”和“armv7”(Xcode4.6 以上版本不再支持armv6，请去掉)3,设置”Build Active Architecture Only”为“NO”。这样你build你的项目的时候就能在iphoe5和iphoe4s里执行。 7.datepicker修改为中文12345方法一[datePicker setLocale:[[NSLocale alloc]initWithLocaleIdentifier:@&quot;zh_CN&quot;]];方法二NSLocale *locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;];//设置为中文显示3 _datePicker.locale = locale; 8.设置属性字体12345678910NSMutableParagraphStyle *ps = [[NSMutableParagraphStyle alloc] init];[ps setLineHeightMultiple:lineHeight];//行高 [ps setLineSpacing:lineHeight];//行间距ps.lineBreakMode = NSLineBreakByTruncatingTail;//末尾省略号ps.lineHeightMultiple = TextLineHeight; //行间距NSMutableDictionary *attributesDic= [NSMutableDictionary dictionary];attributesDic[NSForegroundColorAttributeName] = stringColor;attributesDic[NSFontAttributeName] = stringFont;attributesDic[NSKernAttributeName] = @(0.5);//字间距attributesDic[NSParagraphStyleAttributeName] = ps;NSMutableAttributedString *attributedText = [[NSMutableAttributedString alloc] initWithString:string attributes:attributesDic]; 9.屏幕不允许旋转的方法是什么？1234- (NSUInteger)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window&#123; return UIInterfaceOrientationMaskPortrait;&#125; 10.电池状态栏改变颜色1234567891011121314151617181920212223方法一：不用修改plist [self.navigationController.navigationBar setBarStyle:UIBarStyleBlack];默认的黑色（UIStatusBarStyleDefault）白色（UIStatusBarStyleLightContent）- (UIStatusBarStyle)preferredStatusBarStyle&#123; return UIStatusBarStyleLightContent;&#125;方法二：需要修改plist[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleDefault animated:NO];/ 设置状态栏字体颜色中国移动的颜色改为白色（需要设置plist文件里的View controller-based status bar appearance属性为NO；） [UIApplication sharedApplication].statusBarStyle=UIStatusBarStyleLightContent;//隐藏项目中得状态栏 [[UIApplication sharedApplication]setStatusBarHidden:YES withAnimation:UIStatusBarAnimationFade];info.plist文件中Status bar is initially hidden yesView controller-based status bar appearance NO 11.通过抖动的方式提示用户textField文本输入框的text值为空或错误12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//TextField的晃动:Begin @interface UITextField(shake) - (void)shake; @end @implementation UITextField(shake) - (void)shake &#123; CAKeyframeAnimation *animationKey = [CAKeyframeAnimationanimationWithKeyPath:@&quot;position&quot;]; [animationKey setDuration:0.5f]; NSArray *array = [[NSArrayalloc] initWithObjects: [NSValuevalueWithCGPoint:CGPointMake(self.center.x, self.center.y)], [NSValuevalueWithCGPoint:CGPointMake(self.center.x-5, self.center.y)], [NSValuevalueWithCGPoint:CGPointMake(self.center.x+5, self.center.y)], [NSValuevalueWithCGPoint:CGPointMake(self.center.x, self.center.y)], [NSValuevalueWithCGPoint:CGPointMake(self.center.x-5, self.center.y)], [NSValuevalueWithCGPoint:CGPointMake(self.center.x+5, self.center.y)], [NSValuevalueWithCGPoint:CGPointMake(self.center.x, self.center.y)], [NSValuevalueWithCGPoint:CGPointMake(self.center.x-5, self.center.y)], [NSValuevalueWithCGPoint:CGPointMake(self.center.x+5, self.center.y)], [NSValuevalueWithCGPoint:CGPointMake(self.center.x, self.center.y)], nil]; [animationKey setValues:array]; [array release]; NSArray *times = [[NSArrayalloc] initWithObjects: [NSNumbernumberWithFloat:0.1f], [NSNumbernumberWithFloat:0.2f], [NSNumbernumberWithFloat:0.3f], [NSNumbernumberWithFloat:0.4f], [NSNumbernumberWithFloat:0.5f], [NSNumbernumberWithFloat:0.6f], [NSNumbernumberWithFloat:0.7f], [NSNumbernumberWithFloat:0.8f], [NSNumbernumberWithFloat:0.9f], [NSNumbernumberWithFloat:1.0f], nil]; [animationKey setKeyTimes:times]; [times release]; [self.layeraddAnimation:animationKey forKey:@&quot;TextFieldShake&quot;]; &#125; @end //TextField的晃动:End 12.二维码图片中间添加logo1234567891011121314151617+(UIImage *)addImage:(UIImage *)image1 toImage:(UIImage *)image2&#123; UIGraphicsBeginImageContext(image1.size); //Draw image1 [image1 drawInRect:CGRectMake(0, 0, image1.size.width, image1.size.height)]; //Draw image2 [image2 drawInRect:CGRectMake((image1.size.width - 60)/ 2, (image1.size.height - 60)/2, 60, 60)]; UIImage *resultImage=UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return resultImage;&#125; 13.定义枚举的几种方法1234567891011121314151617181920方法一typedef NS_ENUM(NSInteger, enumCellButtonIndex)&#123; eCBIFirst, eCBISecond,&#125;;方法二typedef enum &#123; commonTag, differentTag, noCommonTag &#125;SortedTag;方法三typedef enum : NSUInteger &#123; eQDTabViewTypeTop, eQDTabViewTypeBottom, eQDTabViewTypeBottomHideBar&#125; QDTabViewType; 14.KVO解决特殊字段（与关键词一样的敏感词）123456-(void)setValue:(id)value forUndefinedKey:(NSString *)key &#123; if ([key isEqualToString:@&quot;id&quot;]) &#123; self.ID = value; &#125; &#125; 15.TabBar上添加消息提示小红点1234567891011121. 如果有数字，直接使用 viewController.tabBarItem.badgeValue = @&quot;1&quot;;2. 没有数字，自己往tabbar加subView。 需要注意的是坐标x，y一定要是整数，否则会有模糊。 UIImageView *dotImage = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;personinfo_unread@2x.png&quot;]]; dotImage.backgroundColor = [UIColor clearColor]; dotImage.tag = RED_DOT_TAG; CGRect tabFrame = tabbarController.tabBar.frame; CGFloat x = ceilf(0.94 * tabFrame.size.width); CGFloat y = ceilf(0.2 * tabFrame.size.height); dotImage.frame = CGRectMake(x, y, 6, 6); [tabbarController.tabBar addSubview:dotImage]; [dotImage release]; 16.让程序在后台较长久的运行1234567891011121314151617181920212223// AppDelegate.h文件@property (assign, nonatomic) UIBackgroundTaskIdentifier backgroundUpdateTask;// AppDelegate.m文件- (void)applicationDidEnterBackground:(UIApplication *)application&#123; [self beingBackgroundUpdateTask]; // 在这里加上你需要长久运行的代码 [self endBackgroundUpdateTask];&#125;- (void)beingBackgroundUpdateTask&#123; self.backgroundUpdateTask = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123; [self endBackgroundUpdateTask]; &#125;];&#125;- (void)endBackgroundUpdateTask&#123; [[UIApplication sharedApplication] endBackgroundTask: self.backgroundUpdateTask]; self.backgroundUpdateTask = UIBackgroundTaskInvalid;&#125; 17.几种小的概念和方法1234567891011121314 1、sleep [NSThread sleepForTimeInterval:4]; 2、活动指示器控件 UIActivityIndicatorView 3、 _cmd的使用 _cmd是iOS内置变量，始终指向当前方法的selector 4、状态加入事件通知中心 [center addObserver:self selector:@selector(applicationWillResignActive) name:UIApplicationWillResignActiveNotification object:nil]; 5、用NSUserDefault保存用户数据 使用方法： 保存： NSInteger selectedIndex = self.segmentedControl.selectedSegmentIndex; [[NSUserDefaults standardUserDefaults] setInteger:selectedIndex forKey:@&quot;selectedIndex&quot;]; 取出： NSNumber *indexNumber = indexNumber = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;selectedIndex&quot;]; if (indexNumber) &#123; NSInteger selectedIndex = [indexNumber intValue]; self.segmentedControl.selectedSegmentIndex = selectedIndex;&#125; 18.有三种方式可以引入静态库文件1234567第一种方式：直接将对应平台的.a文件拖拽至Xcode工程左侧的Groups&amp;Files中，缺点是每次在真机和模拟器编译时都需要重新添加.a文件；第二种方式：使用lipo命令将设备和模拟器的.a合并成一个通用的.a文件，将合并后的通用.a文件拖拽至工程中即可，具体命令如下： lipo -create Release-iphoneos/libbaidumapapi.a Release-iphonesimulator/libbaidumapapi.a -output libbaidumapapi.a第三种方式：1. 将API的libs文件夹拷贝到您的Application工程根目录下2. 在Xcode的Project -&gt; Edit Active Target -&gt; Build -&gt; Linking -&gt; Other Linker Flags中添加-ObjC3. 设置静态库的链接路径，在Xcode的Project -&gt; Edit Active Target -&gt; Build -&gt; Search Path -&gt; Library Search Paths中添加您的静态库目录，比如&quot;$(SRCROOT)/../libs/Release$(EFFECTIVE_PLATFORM_NAME)&quot;，$(SRCROOT)宏代表您的工程文件目录，$(EFFECTIVE_PLATFORM_NAME)宏代表当前配置是OS还是simulator注:静态库中采用ObjectC++实现，因此需要您保证您工程中至少有一个.mm后缀的源文件(您可以将任意一个.m后缀的文件改名为.mm)，或者在工程属性中指定编译方式，即将Xcode的Project -&gt; Edit Active Target -&gt; Build -&gt; GCC4.2 - Language -&gt; Compile Sources As设置为&quot;Objective-C++&quot; 19.SDWebImage清除缓存123清除缓存：[[SDImageCache sharedImageCache] clearDisk];[[SDImageCache sharedImageCache] clearMemory]; 20.view加阴影1234view.layer.shadowOpacity = 0.5;// 阴影透明度view.layer.shadowColor = [UIColor grayColor].CGColor;// 阴影的颜色view.layer.shadowRadius = 3;// 阴影扩散的范围控制view.layer.shadowOffset = CGSizeMake(1, 1);// 阴影的范围 21.将view加到UIWindow上123UIWindow* currentWindow = [UIApplication sharedApplication].keyWindow;[currentWindow addSubview:drawView];_drawView = drawView; 22.AES加密解密。123456789// NSData+AES256.h#import &lt;Foundation/Foundation.h&gt; #import &lt;CommonCrypto/CommonDigest.h&gt; #import &lt;CommonCrypto/CommonCryptor.h&gt; @interface NSData(AES256)- (NSData *)aes256_encrypt:(NSString *)key;- (NSData *)aes256_decrypt:(NSString *)key;@end 123456789101112131415161718192021222324252627282930313233343536373839404142// NSData+AES256.m//#import &quot;NSData+AES256.h&quot;@implementation NSData (AES256)/** 加密 */- (NSData*)aes256_encrypt:(NSString *)key&#123;char keyPtr[kCCKeySizeAES256 + 1];bzero(keyPtr, sizeof(keyPtr));[key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];NSUInteger dataLength = [self length];size_t bufferSize = dataLength + kCCBlockSizeAES128;void *buffer = malloc(bufferSize);size_t numBytesEncrypted = 0;CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128, kCCOptionPKCS7Padding | kCCOptionECBMode, keyPtr, kCCBlockSizeAES128, NULL, [self bytes], dataLength, buffer, bufferSize, &amp;numBytesEncrypted);if (cryptStatus == kCCSuccess) &#123;return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];&#125;free(buffer);return nil;&#125;/** 解密 */- (NSData*)aes256_decrypt:(NSString *)key&#123;char keyPtr[kCCKeySizeAES256 + 1];bzero(keyPtr, sizeof(keyPtr));[key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];NSUInteger dataLength = [self length];size_t bufferSize = dataLength + kCCBlockSizeAES128;void* buffer = malloc(bufferSize);size_t numBytesDecrypted = 0;CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt, kCCAlgorithmAES128, kCCOptionPKCS7Padding | kCCOptionECBMode, keyPtr, kCCBlockSizeAES128, NULL, [self bytes], dataLength, buffer, bufferSize, &amp;numBytesDecrypted);if (cryptStatus == kCCSuccess) &#123;return [NSData dataWithBytesNoCopy:buffer length:numBytesDecrypted];&#125;free(buffer);return nil;&#125;@end 22.GCD异步123456dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;//通知主线程刷新dispatch_async(dispatch_get_main_queue(), ^&#123;//回调或者说是通知主线程刷新，&#125;);&#125;); 23.头部图片下拉放大12345678-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; CGFloat heightWidthRatio = VideoHeaderHeight/ScreenWidth; CGRect frame = self.headerView.frame; frame.origin.y = offsetY; frame.origin.x = offsetY/heightWidthRatio/2; frame.size.height = -offsetY+VideoHeaderHeight; frame.size.width=(-offsetY+VideoHeaderHeight)/heightWidthRatio;&#125; 24.获取版本号，DisPlayName等1234NSDictionary *infoDict = [[NSBundle mainBundle] infoDictionary]; _nameLabel.text = [infoDict objectForKey:@&quot;CFBundleDisplayName&quot;]; _versionLabel.text = [NSString stringWithFormat:@&quot;版本号: V%@&quot;,[infoDict objectForKey:@&quot;CFBundleShortVersionString&quot;]]; _rightsLabel.text = [NSString stringWithFormat:@&quot;%@ Jucailife.cn京ICP备 15058272&quot;,[[NSDate date] year]]; 25.常用监听事件 12345**键盘**//键盘出现时[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWasShown:) name:UIKeyboardWillShowNotification object:nil];//键盘收回时[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil]; 12345678910**TextField**//适用场景，打字时弹出suggestion//TextField 编辑状态时(通知)[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textFieldChanged:) name:UITextFieldTextDidChangeNotification object:textField];//或者 addTargetUIControlEventEditingDidBegin = 1 &lt;&lt; 16,//1 &lt;&lt; 17 代表:2的17次方 UIControlEventEditingChanged = 1 &lt;&lt; 17,//1 &lt;&lt; 18 代表:2的18次方UIControlEventEditingDidEnd = 1 &lt;&lt; 18,//1 &lt;&lt; 19 代表:2的19次方UIControlEventEditingDidEndOnExit = 1 &lt;&lt; 19,[field addTarget:self action:@selector(textFieldDidChanged) forControlEvents:UIControlEventEditingDidBegin | UIControlEventValueChanged | UIControlEventEditingDidEnd]; 26.监听ScrollView的滚动 1234567891011121314151617181920- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123;//偏移量 CGFloat offsetY = scrollView.contentOffset.y;if (offsetY &gt; 0) &#123; //往上滑&#125;else &#123;//往下滑&#125;//加速度 UIPanGestureRecognizer* pan = scrollView.panGestureRecognizer;CGFloat velocity = [pan velocityInView:scrollView].y;if (velocity&lt;-5) &#123; //上&#125;else if (velocity&gt;5) &#123; //下&#125;&#125; 27.字符串编码123456789101112有的时候咱们会碰见字符串里有一些特殊字符在转成URL的时候 会出现转换不了的情况，这个时候需要对字符串进行编码9.0以前使用stringByAddingPercentEscapesUsingEncoding9.0之后使用stringByAddingPercentEncodingWithAllowedCharactersNSString *resourcePath = @&quot;http://www.baidu.com?tickets=[&#123;\\&quot;num\\&quot;:\\&quot;1\\&quot;,\\&quot;priceId\\&quot;:\\&quot;8a82824756\\&quot;&#125;]&quot;; NSString *encodePath ;if (!IOS7_OR_LATER) &#123; encodePath = [resourcePath stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];&#125;else&#123; encodePath = [resourcePath stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet characterSetWithCharactersInString:@&quot;`#%^&#123;&#125;\\&quot;[]|\\\\&lt;&gt; &quot;].invertedSet];&#125; 28.ScrollView的ContentOffSet 29.ImageView填充方式。 30.绘制一条虚线。1234567891011121314151617181920212223242526/* **lineFrame: 虚线的frame **length: 虚线中短线的宽度 **spacing: 虚线中短线之间的间距 **color: 虚线中短线的颜色*/+(UIView *)creatDashedLineWithFrame:(CGRect)lineFrame lineLenght:(int)length lineSpacing:(int)spacing lineColor:(UIColor *)color&#123; UIView *dashLine = [[UIView alloc]initWithFrame:lineFrame]; dashLine.backgroundColor = [UIColor clearColor]; CAShapeLayer *shapeLayer = [CAShapeLayer layer]; [shapeLayer setBounds:dashLine.bounds]; [shapeLayer setPosition:CGPointMake(CGRectGetWidth(dashLine.frame)/2, CGRectGetHeight(dashLine.frame))]; [shapeLayer setFillColor:[UIColor clearColor].CGColor]; [shapeLayer setStrokeColor:color.CGColor]; [shapeLayer setLineWidth:CGRectGetHeight(dashLine.frame)]; [shapeLayer setLineJoin:kCALineJoinRound]; [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:length],[NSNumber numberWithInt:spacing],nil]]; CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, NULL, 0, 0); CGPathAddLineToPoint(path, NULL, CGRectGetWidth(dashLine.frame), 0); [shapeLayer setPath:path]; CGPathRelease(path); [dashLine.layer addSublayer:shapeLayer]; return dashLine;&#125; 31. 播放视频。1234567891011121314151617181920212223#import &lt;MediaPlayer/MediaPlayer.h&gt;// =================================================#pragma mark - 播放视频// =================================================+(void)playVideoWithUrl:(NSString *)url andController:(UIViewController *)controller&#123; MPMoviePlayerViewController *playerVC = [[MPMoviePlayerViewController alloc] initWithContentURL:[NSURL URLWithString:url]]; playerVC.moviePlayer.movieSourceType = MPMovieSourceTypeFile; // playerVC.moviePlayer.repeatMode = MPMovieRepeatModeOne; [controller presentMoviePlayerViewControllerAnimated:playerVC]; &#125;+(void)playVideoWithLocalPath:(NSString *)localDocumentName andController:(UIViewController *)controller&#123; NSString *path = [[NSBundle mainBundle] pathForResource:localDocumentName ofType:nil]; NSURL *url = [[NSURL alloc] initFileURLWithPath:path]; MPMoviePlayerViewController *playerVC = [[MPMoviePlayerViewController alloc] initWithContentURL:url]; playerVC.moviePlayer.movieSourceType = MPMovieSourceTypeFile; // playerVC.moviePlayer.repeatMode = MPMovieRepeatModeOne; [controller presentMoviePlayerViewControllerAnimated:playerVC];&#125; 32. iPhone屏幕尺寸、分辨率及适配。 看这个大神的帖子足够 33. 验证邮箱、电话、和QQ 1234567891011121314151617181920212223242526272829- (BOOL) validateEmail:(NSString *)email&#123;NSString *emailRegex = @&quot;[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\\\\\.[A-Za-z]&#123;2,4&#125;&quot;;NSPredicate *emailTest = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, emailRegex];return [emailTest evaluateWithObject:email];&#125;//手机号码验证- (BOOL)validateMobile:(NSString *)phone&#123;NSString *MOBILE = @&quot;^1[34578]\\\\\\\\d&#123;9&#125;$&quot;;NSPredicate *regexTestMobile = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,MOBILE];if ([regexTestMobile evaluateWithObject:phone]) &#123;return YES;&#125;else &#123;return NO;&#125;&#125;//QQ号码验证- (BOOL)validateQQ:(NSString *)qq&#123;NSString *QQ = @&quot;[1-9][0-9]&#123;4,&#125;&quot;;NSPredicate *regexTestQQ = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,QQ];if ([regexTestQQ evaluateWithObject:qq]) &#123;return YES;&#125;else &#123;return NO;&#125;&#125; 34. UISegmentedControl（直接拷来用）12345678910111213141516171819-(UISegmentedControl *)segementControl&#123;if (_segementControl == nil) &#123;UISegmentedControl *segmentedControl = [[UISegmentedControl alloc] initWithItems:@[@&quot;餐馆&quot;, @&quot;菜单&quot;]];segmentedControl.frame = CGRectMake((ScreenWidth-150)/2, 10, 150, 30);// 设置进入页面后的所处的位置segmentedControl.selectedSegmentIndex = 0;//选中的颜色segmentedControl.tintColor = [UIColor redColor];[segmentedControl addTarget:self action:@selector(segmentedControlValueChanged:) forControlEvents:UIControlEventValueChanged];[self.segementWrapView addSubview:segmentedControl];_segementControl = segmentedControl;&#125;return _segementControl;&#125;- (void)segmentedControlValueChanged:(UISegmentedControl *) segmentedControl &#123;if (0 == segmentedControl.selectedSegmentIndex) &#123;&#125;&#125; 35. iOS一键加群123456789- (BOOL)joinGroup:(NSString *)groupUin key:(NSString *)key&#123;NSString *urlStr = [NSString stringWithFormat:@&quot;mqqapi://card/show_pslcard? src_type=internal&amp;version=1&amp;uin=%@&amp;key=%@&amp;card_type=group&amp;source=external&quot;, @&quot;240555441&quot;,@&quot;60d319547ddffeacefe646f0d273e988a26dc70065bdedfd6a63c484e3c353c0&quot;];NSURL *url = [NSURL URLWithString:urlStr];if([[UIApplication sharedApplication] canOpenURL:url])&#123;[[UIApplication sharedApplication] openURL:url];return YES;&#125;else return NO;&#125; 36.CLLocation的一些黑魔法 (1).pausesLocationUpdatesAutomatically locationManager.pausesLocationUpdatesAutomatically = NO;贴上一段官网对这个属性的描述：Allowing the location manager to pause updates can improve battery life on the target device without sacrificing location data. When this property is set to YES, the location manager pauses updates (and powers down the appropriate hardware) at times when the location data is unlikely to change. For example, if the user stops for food while using a navigation app, the location manager might pause updates for a period of time. You can help the determination of when to pause location updates by assigning a value to the activityTypeproperty. 大致的意思就是如果这个属性设置成YES（默认的也是YES），那么系统会检测如果设备有一段时间没有移动，就会自动停掉位置更新服务。这里需要注意的是，一旦定位服务停止了，只有当用户再次开启App的时候定位服务才会重新启动。这里的一段时间是系统自动判定的，可以通过设置activityTypeproperty这个属性来决定这个时间的长短。API的意思是，类似导航类的App,系统检验的时间会稍长一点，想运动类的App，就会比导航类的短一点。但是具体时间还是由系统来决定。 (2).headingFilter123456locationManager.headingFilter = 45;//设置只有当设备方向的改变值超过该属性值时才激发delegate的方法。- (void)locationManager:(CLLocationManager *)manager didUpdateHeading:(CLHeading *)newHeading&#123;MKAnnotationView *anv = [_mapView viewForAnnotation:_mapView.userLocation];anv.transform = CGAffineTransformMakeRotation(newHeading.magneticHeading/360.0*2*M_PI);&#125; (3).deferredUpdates默认地，定位服务的代理会每秒钟都更新一次位置，这样对电池的消耗量会特别地大。除了设置pausesLocationUpdatesAutomatically这个属性以外，iOS还提供了DeferredUpdates的机制。123官方API文档：- (void)allowDeferredLocationUpdatesUntilTraveled:(CLLocationDistance)distance timeout:(NSTimeInterval)timeout distance：The distance (in meters) from the current location that must be travelled before event delivery resumes. To specify an unlimited distance, pass the CLLocationDistanceMaxconstant.timeout：The amount of time (in seconds) from the current time that must pass before event delivery resumes. To specify an unlimited amount of time, pass the CLTimeIntervalMax constant. 就是你可以设置让系统每隔多远或者每隔多长时间更新一次位置。注意是“或”的关系，满足一个就会更新。使用这个方法有很多要注意的地方：desiredAccuracy必须设置成kCLLocationAccuracyBestdistanceFilter必须设置成kCLErrorDeferredDistanceFiltered必须能够使用GPS进行定位（而不仅仅是移动数据或者Wi-Fi）非常重要的一点，DeferredUpdates只会出现在设备进入低耗电量的状态，App运行在前台或者设备连接在Xcode上正在调试是不会触发的。（所以不可能在Debug的时候打印Log来检验，要调试的话，需要写一些Log存在本地的数据库） 37.真机中.Plist文件的读写.Plist文件的读写默认真机不管用,因为在真机环境下,App在Xcode中的Resources文件夹都是不可写的.所以我们要在App第一次运行时将需要修改且长久保存的数据放到Document目录下:12345- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123;[self initDataFile];return YES；&#125; 123456789101112131415161718//在Document目录中初始化地图数据文件,因为该目录下文件可写且可以持久保存-(void)initDataFile&#123;NSString *docPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];//取得目标文件路径NSString *path = [docPath stringByAppendingPathComponent:@&quot;titleList.plist&quot;];NSFileManager *fm = [NSFileManager defaultManager];//如果目标文件不存在说明是App第一次运行,需要将相关可修改数据文件拷贝至目标路径.if (![fm fileExistsAtPath:path]) &#123;NSError *error = nil;//取得源文件路径NSString *paths = [[NSBundle mainBundle] pathForResource:@&quot;titleList&quot; ofType:@&quot;plist&quot;];if (![fm copyItemAtPath:paths toPath:path error:&amp;error]) &#123;&#125;&#125;&#125; 12345678//.Plist文件的读写NSArray *arrPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *strDocBase = ([arrPaths count] &gt; 0) ? [arrPaths objectAtIndex:0] : nil;_path = [strDocBase stringByAppendingPathComponent:@&quot;titleList.plist&quot;];//读取数据NSArray *data = [NSArray arrayWithContentsOfFile:_path];//写入数据[_datas writeToFile:_path atomically:YES]; 38.UITableView的Group样式下顶部空白处理123//分组列表头部空白处理UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 0, 0.1)];self.tableView.tableHeaderView = view; 39.获取某个view所在的控制器12345678910111213- (UIViewController *)viewController&#123;UIViewController *viewController = nil;UIResponder *next = self.nextResponder;while (next)&#123;if ([next isKindOfClass:[UIViewController class]])&#123;viewController = (UIViewController *)next;break;&#125;next = next.nextResponder;&#125;return viewController;&#125; 40.两种方法删除NSUserDefaults所有记录1234567891011121314//方法一NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];//方法二- (void)resetDefaults&#123;NSUserDefaults * defs = [NSUserDefaults standardUserDefaults];NSDictionary * dict = [defs dictionaryRepresentation];for (id key in dict)&#123;[defs removeObjectForKey:key];&#125;[defs synchronize];&#125; 41.获取图片某一点的颜色12345678910111213141516171819202122232425262728- (UIColor*) getPixelColorAtLocation:(CGPoint)point inImage:(UIImage *)image&#123;UIColor* color = nil;CGImageRef inImage = image.CGImage;CGContextRef cgctx = [self createARGBBitmapContextFromImage:inImage];if (cgctx == NULL) &#123;return nil; /* error */&#125;size_t w = CGImageGetWidth(inImage);size_t h = CGImageGetHeight(inImage);CGRect rect = &#123;&#123;0,0&#125;,&#123;w,h&#125;&#125;;CGContextDrawImage(cgctx, rect, inImage);unsigned char* data = CGBitmapContextGetData (cgctx);if (data != NULL) &#123;int offset = 4*((w*round(point.y))+round(point.x));int alpha = data[offset];int red = data[offset+1];int green = data[offset+2];int blue = data[offset+3];color = [UIColor colorWithRed:(red/255.0f) green:(green/255.0f) blue:(blue/255.0f) alpha:(alpha/255.0f)];&#125;CGContextRelease(cgctx);if (data) &#123;free(data);&#125;return color;&#125; 42.禁止锁屏 1234默认情况下，当设备一段时间没有触控动作时，iOS会锁住屏幕。但有一些应用是不需要锁屏的，比如视频播放器。[UIApplication sharedApplication].idleTimerDisabled = YES;或[[UIApplication sharedApplication] setIdleTimerDisabled:YES]; 43.模态推出透明界面1234567891011UIViewController *vc = [[UIViewController alloc] init];UINavigationController *na = [[UINavigationController alloc] initWithRootViewController:vc];if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8.0)&#123;na.modalPresentationStyle = UIModalPresentationOverCurrentContext;&#125;else&#123;self.modalPresentationStyle=UIModalPresentationCurrentContext;&#125;[self presentViewController:na animated:YES completion:nil]; 44.iOS 获取汉字的拼音123456789101112+ (NSString *)transform:(NSString *)chinese&#123;//将NSString装换成NSMutableStringNSMutableString *pinyin = [chinese mutableCopy];//将汉字转换为拼音(带音标)CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformMandarinLatin, NO);NSLog(@&quot;%@&quot;, pinyin);//去掉拼音的音标CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformStripCombiningMarks, NO);NSLog(@&quot;%@&quot;, pinyin);//返回最近结果return pinyin;&#125; 45.判断对象是否遵循了某协议1234if ([self.selectedController conformsToProtocol:@protocol(RefreshPtotocol)])&#123;[self.selectedController performSelector:@selector(onTriggerRefresh)];&#125; 46.判断view是不是指定视图的子视图 1BOOL isView = [textView isDescendantOfView:self.view]; 47.取消UICollectionView的隐式动画123456789101112131415161718192021UICollectionView在reloadItems的时候，默认会附加一个隐式的fade动画，有时候很讨厌，尤其是当你的cell是复合cell的情况下(比如cell使用到了UIStackView)。下面几种方法都可以帮你去除这些动画//方法一[UIView performWithoutAnimation:^&#123;[collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];&#125;];//方法二[UIView animateWithDuration:0 animations:^&#123;[collectionView performBatchUpdates:^&#123;[collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];&#125; completion:nil];&#125;];//方法三[UIView setAnimationsEnabled:NO];[self.trackPanel performBatchUpdates:^&#123;[collectionView reloadItemsAtIndexPaths:@[[NSIndexPath indexPathForItem:index inSection:0]]];&#125; completion:^(BOOL finished) &#123;[UIView setAnimationsEnabled:YES];&#125;]; 后话：附上之前写的文章，欢迎指正：荼菜的iOS笔记–Core Animation 核心动画 荼菜的iOS笔记–UIView的几个Block动画荼菜的iOS笔记–UITableViewCell的各种操作（刷新、插入、删除、动画）荼菜的iOS笔记–一张图记住所有git命令行操作。荼菜的iOS笔记–一张图告诉你程序员需要知道的这些网站。荼菜的iOS笔记–图片裁剪黑魔法。荼菜的iOS笔记–iOS自动打包脚本（Python） 荼菜的iOS笔记–我的编码规范参考。荼菜的iOS笔记–iOS基础优秀博客总结ToDoList荼菜的iOS笔记–Xcode Tips当然，我还写过诗。。。光。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"荼菜的iOS笔记--图片裁剪黑魔法。","date":"2015-11-07T14:33:50.000Z","path":"2015/11/07/荼菜的iOS笔记-图片裁剪黑魔法。/","text":"前言：最近在做一款对话交互式的美食机器人应用，目前内测阶段，效果如上图。最近闲暇之余会把期间总结的一些知识点写下来，做个总结。前期有段时间困扰了我很久一个问题由于工程中的图片数据抓取自不同平台，所以图片的大小尺寸不一定，而放置图片的imageView尺寸是一定的，不作任何处理的话会导致图片拉伸变形，因此找了好久解决办法，现把它拿出来。 *图片裁剪代码：12345678910111213141516171819#import &lt;UIKit/UIKit.h&gt;#import &quot;UIImageView+WebCache.h&quot;@interface UIImageView (WebImage)/** * @author Tucai, 16-02-23 12:02:53 * * 设置能够自动裁剪的网络图，基于SDWebImage实现 * */// 模糊图渲染- (void)renderBlurredImageWithUrl:(NSString *)url placeholder:(UIImage *)placeholder completed:(imageDownloadCompletedBlock) completedBlock;//按比例缩放网络图片- (void)yg_setTrimImageWithUrl:(NSString *)url placeholderImage:(UIImage *)placeholder; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#import &quot;UIImageView+WebImage.h&quot;#import &quot;NSString+URLEncoding.h&quot;@implementation UIImageView (WebImage)#pragma mark - 模糊图渲染- (void)renderBlurredImageWithUrl:(NSString *)url placeholder:(UIImage *)placeholder completed:(imageDownloadCompletedBlock) completedBlock&#123; // 这里必须开启内存缓存 [SDWebImageManager sharedManager].imageCache.shouldCacheImagesInMemory = YES; // 渲染背景 __weak typeof(self) ws = self; [ws sd_setImageWithURL:[NSURL URLWithString:url] completed:^(UIImage *webImage, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) &#123; // 999 是一个标记 if (ws.tag != 999) &#123; UIVisualEffectView *visualView = [[UIVisualEffectView alloc] initWithFrame:ws.bounds]; UIBlurEffect *effect = [UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]; visualView.effect = effect; NSLog(@&quot;only once&quot;); [ws addSubview:visualView]; ws.tag = 999; &#125; ws.alpha =0.6; ws.image = nil; ws.image = webImage; if (completedBlock) &#123; completedBlock(webImage); &#125; &#125;];&#125;#pragma mark - 裁剪图片- (void)yg_setTrimImageWithUrl:(NSString *)url placeholderImage:(UIImage *)placeholder&#123; __weak typeof(self) ws = self; [SDWebImageManager sharedManager].imageCache.shouldCacheImagesInMemory = NO; [self sd_setImageWithURL:[NSURL URLWithString:url] placeholderImage:placeholder completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) &#123; if (image) &#123; UIImage *img=[self yg_trimImageWithImage:image]; ws.image=img; &#125;else&#123; ws.image =[self yg_trimImageWithImage:placeholder]; &#125; &#125;];&#125;-(UIImage *)yg_trimImageWithImage:(UIImage *)image&#123; //imageView的宽高比 CGFloat imageViewWidthHeightRatio =self.frame.size.width/self.frame.size.height; //屏幕分辨率// CGFloat imageScale = [[UIScreen mainScreen] scale]; CGFloat imageScale = 1; CGFloat imageWith = image.size.width*imageScale; CGFloat imageHeight =image.size.height*imageScale; //image的宽高比 CGFloat imageWidthHeightRatio =imageWith/imageHeight; CGImageRef imageRef = nil; CGRect rect; // NSLog(@&quot;\\nimageWith === %f\\nimageHeight === %f\\nImageView宽高比 == %f\\nimageScale == %f&quot;,imageWith,imageHeight,imageViewWidthHeightRatio,imageScale); if (imageWidthHeightRatio&gt;imageViewWidthHeightRatio) &#123; rect = CGRectMake((imageWith-imageHeight*imageViewWidthHeightRatio)/2, 0, imageHeight*imageViewWidthHeightRatio, imageHeight); &#125;else if (imageWidthHeightRatio&lt;imageViewWidthHeightRatio) &#123; rect = CGRectMake(0, (imageHeight-imageWith/imageViewWidthHeightRatio)/2, imageWith, imageWith/imageViewWidthHeightRatio); &#125;else &#123; rect = CGRectMake(0, 0, imageWith, imageHeight); &#125; imageRef = CGImageCreateWithImageInRect([image CGImage], rect); UIImage *res = [UIImage imageWithCGImage:imageRef scale:imageScale orientation:UIImageOrientationUp]; /** 一定要，千万要release，否则等着内存泄露吧，稍微高清点的图一张图就是几M内存，很快App就挂了 */ CGImageRelease(imageRef); return res;&#125;@end 后话：附上之前写的文章，欢迎指正： 荼菜的iOS笔记–Core Animation 核心动画 荼菜的iOS笔记–UIView的几个Block动画荼菜的iOS笔记–一些实用功能。荼菜的iOS笔记–UITableViewCell的各种操作（刷新、插入、删除、动画）荼菜的iOS笔记–一张图记住所有git命令行操作。荼菜的iOS笔记–一张图告诉你程序员需要知道的这些网站。荼菜的iOS笔记–iOS自动打包脚本（Python） 荼菜的iOS笔记–我的编码规范参考。荼菜的iOS笔记–iOS基础优秀博客总结ToDoList荼菜的iOS笔记–Xcode Tips当然，我还写过诗。。。光。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"光。","date":"2015-04-18T22:55:36.000Z","path":"2015/04/19/光。/","text":"我逆着光走去朦胧全是人影可我看不到任何人的面孔管他呢因为我知道光的方向有你你逆着它你认得出我","tags":[{"name":"poem","slug":"poem","permalink":"http://yoursite.com/tags/poem/"},{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"荼菜的iOS笔记--一张图记住所有git命令行操作。","date":"2014-01-22T02:05:57.000Z","path":"2014/01/22/荼菜的iOS笔记-一张图记住所有git命令行操作。/","text":"附上之前记录的笔记，留作纪念：12克隆代码：git clone -b Dev git@github.com:公司/xxxx.git 12345提交代码：* cd Desktop/jucai-ios-app //进入工程目录* git status //查看分支状体* git add . //添加所有* git commit -m &quot;Release Version&quot; // 提交修改说明 12345删除分支：* cd Desktop/jucai-ios-app //进入工程目录* git branch //查看分支列表* git branch -D EasySearch //删除本地分支* git push origin :EasySearch //删除远程分支 123456合并分支：* cd Desktop/jucai-ios-app //进入需要合并的分支* git branch //查看分支列表* git merge branchName //与branchName合并* ESC + : wq* git status -s // 查看冲突 有了上面那种图，这些都不用看了。 后话：附上之前写的文章，欢迎指正：荼菜的iOS笔记–Core Animation 核心动画 荼菜的iOS笔记–UIView的几个Block动画荼菜的iOS笔记–一些实用功能。荼菜的iOS笔记–UITableViewCell的各种操作（刷新、插入、删除、动画）荼菜的iOS笔记–一张图告诉你程序员需要知道的这些网站。荼菜的iOS笔记–图片裁剪黑魔法。荼菜的iOS笔记–iOS自动打包脚本（Python） 荼菜的iOS笔记–我的编码规范参考。荼菜的iOS笔记–iOS基础优秀博客总结ToDoList荼菜的iOS笔记–Xcode Tips当然，我还写过诗。。。光。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]}]